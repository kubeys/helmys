{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"YS \u2014 YAML Done Wisely","text":"YS (say \"wise\") is the best way to work with YAML <p>  Learn More About YS</p> <ul> <li> <p> Take Full Control of Your YAML</p> <ul> <li>YS is always 100% valid YAML\u00a0 <ul> <li>Lint, Query, Validate w/ existing tools</li> </ul> </li> <li>Created by YAML inventor/maintainer</li> <li>YS has YAML Loaders for all languages   Same Capabilities, Features, Bugs and Fixes</li> <li>A Common &amp; Consistent YAML Experience   (with or without using YS logic features)</li> </ul> </li> <li> <p> YAML Made Functional</p> <pre><code>!YS-v0:\nvars =: load('vars.yaml')\njson-file =: 'data.json'\n\na normal key: and normal value\nname:: ENV.USER:uc1\ncolor:: vars.colors:shuffle.0\nsome stuff::\n  curl(\"https://example.com/$json-file\")\n    .stuff.take(rand-int(5).++)\n:when ENV.DEBUG_VARS::\n  debug:: vars\n</code></pre> </li> <li> <p> Simplify your existing YAML</p> <ul> <li>Refactor, Deduplicate, DRY</li> <li>Over 1000 standard functions built in</li> <li>Dozens of built in libraries</li> <li>External libraries as well</li> <li>Define your own functions and libraries</li> <li>Limit YS capabilities to your exact needs</li> </ul> </li> <li> <p> Plays Well with DevOps Tools</p> <ul> <li>HelmYS for Kubernetes Helm charts</li> <li>CI/CD, Docker, Ansible, etc.</li> <li>Your existing YAML files are valid YS!</li> <li>Take them to the next level</li> </ul> </li> <li> <p> Import, Transform, Interpolate and More</p> <ul> <li>Load YS in your programs</li> <li>Script Automation with YS</li> <li>Query and Transform YAML data</li> <li>Compile YS to binary executables</li> </ul> </li> <li> <p> Learn YS Today!</p> <ul> <li>YS Exercism Track\u00a0 </li> <li>KubeCon 2024 YS Tutorial\u00a0 </li> <li>YS on Rosetta Code\u00a0 </li> <li>YS Documentation\u00a0 </li> </ul> </li> </ul> <ul> <li> <p> \"Zero to YS in 10 seconds!\"</p> <pre><code>curl -s https://getys.org/ys | bash\n# Adjust PATH if asked to.\nys --help\nys -e 'say: \"Hello, World!\"'\n</code></pre> </li> </ul>"},{"location":"about-website/","title":"About This Website","text":"<p>This website was built using the (OMG it's the best site generator in the universe!!!) Material for MkDocs\u00a0  theme for the MkDocs\u00a0  static site generator, and many of its plugins.</p>"},{"location":"about-website/#ys-enhancement","title":"YS Enhancement","text":"<p>While the Material for MkDocs theme is already feature-rich, we improved things a bit more by using YS.</p> <p>We also use a Makefile\u00a0  to automate all the MkDocs build steps like installing Python packages, creating and enabling a virtual environment, building the site, and serving it both locally and on GitHub Pages.</p> <p>All you need to do in the YS mono-repo's <code>www</code> directory\u00a0  is run these <code>make</code> commands:</p> <ul> <li><code>make serve</code> \u2014 Serve the site locally (after doing any necessary setup)</li> <li><code>make publish website=stage</code> \u2014 Publish the site to    https://stage.yamlscript.org\u00a0 </li> <li><code>make publish website=live</code> \u2014 Publish the site to    https://www.yamlscript.org\u00a0 </li> <li><code>make clean</code> \u2014 Remove the generated files</li> <li><code>make realclean</code> \u2014 Remove the generated files and the virtual environment</li> </ul> <p>So simple!</p>"},{"location":"about-website/#generating-the-mkdocsyml","title":"Generating the <code>mkdocs.yml</code>","text":"<p>MkDocs uses a <code>mkdocs.yml</code> YAML file for its configuration. As that file grew in size, we found it easier to manage by splitting it into multiple files, and using the <code>config.ys</code> file to include them.</p> <ul> <li><code>config.ys</code>    \u2014 The main configuration file</li> <li><code>config/*.yaml</code>    \u2014 The included configuration files</li> </ul>"},{"location":"about-website/#markdownys","title":"MarkdownYS","text":"<p>Certain pages (like library method documentation) are annoying to write because they require a lot of repeated boilerplate. We made a tool called <code>mdys</code> that lets you write YAML data inside of Markdown and specify a YS function to turn it into Markdown.</p> <p>If you have the documentation for 100 methods and later you want to change the formatting for them, you only need to tweak the YS function.</p> <p>A good example of this is the YS Standard Library documentation. Click on the \"Edit this page\" link to see the source.</p> <p>The YAML data starts with:</p> <pre><code>```mdys:stdlib\nString functions:\n- base64-decode(Str) Str: Decode a base64 string\n</code></pre> <p>This YAML gets loaded into an object and passed to the <code>mdys-stdlib</code> </p> <p>Note</p> <p>The <code>Makefile</code> takes care of watching any <code>.mdys</code> files and converting them to <code>.md</code> files whenever they change (when serving the site locally).</p> <p>Working with MarkdownYS in MkDocs is as easy as working with Markdown.</p>"},{"location":"about/","title":"About YS","text":"<p>YS (aka YAMLScript) is a functional programming language that uses YAML\u00a0  as its syntax. Its primary intent is to provide YAML with the capabilities of a general purpose programming language for all its users and use cases. YS does this in a seamless fashion, that feels like a very natural extension of the YAML you know and use today.</p> <p>All YS files are guaranteed to be valid YAML files</p> <p>Furthermore, all<sup>1</sup> YAML files (and thus all JSON files) are valid YS, and YS will load them as they were intended.</p> <p>YS enables an extensive amount of programming capabilities that can be used at any level and to any degree. The more commonly needed capabilities include:</p> <ul> <li>Loading data from external sources: files, databases, web, APIs, etc.</li> <li>Assigning values to variables, and using them in expressions</li> <li>Interpolating variables into strings</li> <li>Data path queries, conditionals, loops, transformations, etc</li> <li>Defining your own functions and libraries</li> <li>Builtin libraries with over 1000 functions for all common tasks</li> <li>Using external libraries and dependencies</li> <li>Making system calls, and accessing environment variables</li> </ul> <p>Here's file that demonstrates some of the capabilities of YS: <pre><code>!YS-v0:  # Allow functional capabilities in this YAML document\n\n# Define a local function inline:\n::\n  defn greet(name='World'): |\n    Hi, I'm $name,\n    Nice to meet you!\n\nvars =: load('vars.yaml')     # Load another YAML file\n\n# A YAML mapping:\nkey: value                    # A normal YAML key value pair of strings\n\n# Get a random name and anchor it:\nname:: &amp;name vars\n       .names.rand-nth()\n\n# System call to get the date:\ndate:: \"Today is\n        $(sh('date')\n        .out:chomp)\"\nme =: ENV.USER                # Assign USER env var to 'me' var\nuser:: uc(me)                 # Uppercase me\n:when (rand(10) ** 2) &gt; 1::   # Add mapping pair conditionally\n  maybe: this pair\n\n# Various ways to call a function:\ngreeting 1:: greet()\ngreeting 2:: lc(me):uc1:greet\ngreeting 3::\n  greet: -'&lt;' + *name + '&gt;'\n</code></pre></p> <p>This file goes a bit overboard from what you would typically see in a YAML file using YS, but it's just to show off the capabilities listed above.</p> <p>Use the <code>ys</code> command to evaluate the file to YAML or JSON: <pre><code>$ ys -Y file.yaml\nkey: value\nname: Alice\ndate: Today is Thu Feb 13 11:49:09 AM EST 2025\nuser: INGY\nmaybe: this pair\ngreeting 1: |\n  Hi, I'm World,\n  Nice to meet you!\ngreeting 2: |\n  Hi, I'm Ingy,\n  Nice to meet you!\ngreeting 3: |\n  Hi, I'm &lt;Alice&gt;,\n  Nice to meet you!\n</code></pre></p> <p>YS was created by one of the original YAML authors, Ingy d\u00f6t Net. It adheres to the YAML 1.2 specification\u00a0  and is implemented very much as the spec describes. The YS compiler (YS compiles to the Clojure Lisp for subsequent evaluation) is implemented as a YAML loader.</p> <p>Clojure\u00a0  is a JVM based functional language that known for its concise, powerful syntax. YS offers you these powers but without the need for Lisp syntax or a JVM.</p> <p>YS is compiled to the <code>ys</code> standalone native binary executable, and to the <code>libyamlscript</code> shared library, for common operating systems / architectures\u00a0 .</p> <p>This shared library can be bound to almost all modern  programming languages as a YAML Loader module. It currently ships to these 10 languages:</p> <ul> <li>Clojure\u00a0 </li> <li>Go\u00a0 </li> <li>Java\u00a0 </li> <li>Julia\u00a0 </li> <li>NodeJS\u00a0 </li> <li>Perl\u00a0 </li> <li>Python\u00a0 </li> <li>Raku\u00a0 </li> <li>Ruby\u00a0 </li> <li>Rust\u00a0 </li> </ul> <p>with many more on the way.</p> <ol> <li> <p>There are ways to write YAML that is not valid YS, but they are highly unlikely to be seen in places where YAML is used as a configuration language. If a YAML file can be converted to JSON and then back to YAML, without changing semantics, then it is valid YS.\u00a0\u21a9</p> </li> </ol>"},{"location":"cicd/","title":"YS for CI/CD","text":"<p>YS is a great language for CI/CD pipelines.</p> <p>Regardless of what CI/CD system you are using, you can use YS to make those configuration files much more maintainable and powerful.</p>"},{"location":"cicd/#the-problem","title":"The Problem","text":"<p>CI/CD pipelines are often written in YAML but YAML is not a programming language. This means that you can't do things like:</p> <ul> <li>Load data from other files, databases, APIs, URLs, etc</li> <li>Query data structures to get the data you need</li> <li>Access environment variables</li> <li>Assign variables</li> <li>Reference other parts of the YAML file</li> <li>Interpolate variables and function calls into strings</li> <li>Use loops and conditional logic</li> <li>Transform data structures using 100s of built-in functions</li> <li>Define and call your own functions</li> <li>Use external libraries</li> <li>Run shell commands</li> </ul>"},{"location":"cicd/#the-solution","title":"The Solution","text":"<p>YS can do all of these things, and more, and it does it all in a way that is completely compatible with YAML. You can start with your existing YAML files and add YS capabilities to them as much or as little as you need.</p>"},{"location":"cicd/#the-next-problem","title":"The Next Problem","text":"<p>YS is a new language, and your CI/CD system probably doesn't support it out of the box.</p> <p>The YS team hopes that over time YS YAML loaders will become the preferred way to load YAML config file in almost any situation, including CI/CD systems.</p>"},{"location":"cicd/#the-general-solution","title":"The General Solution","text":"<p>Until then, you can use YS to generate the YAML files that your CI/CD system expects.</p> <p>A typical way to do this is to copy your existing YAML file, say <code>pipeline.yaml</code>, and then run this command:</p> <pre><code>ys -Y pipeline.ys &gt; pipeline.yaml\n</code></pre> <p>This will generate a new <code>pipeline.yaml</code> file that should be semantically equivalent to the original <code>pipeline.yaml</code> file. The comments and formatting will be different, but the data should be the same.</p> <p>Next you'll want to add that command to your CI/CD system so that it runs every time you make a change to your <code>pipeline.ys</code> file. This could be as simple as adding a Makefile (see below) with a Git hook, but that's up to you.</p>"},{"location":"cicd/#first-time-validation","title":"First time validation","text":"<p>After converting your <code>pipeline.yaml</code> file to <code>pipeline.ys</code> the first time, you should validate that the conversion is correct.</p> <p>One way to do this is by running:</p> <pre><code>$ ys -pe 'ARGS.0:read:yaml/load == ARGS.1:read:yaml/load' -- \\\n    &lt;(git show HEAD:pipeline.yaml) pipeline.yaml\ntrue\n</code></pre> <p>If the output is <code>true</code>, then the conversion is correct. If the output is <code>false</code>, then you'll need to investigate why.</p> <p>After the first time, you can refactor your <code>pipeline.ys</code> file with YS any way you like. The resulting <code>pipeline.yaml</code> file should never change at all. This makes refactoring so much easier, because you will know immediately if you broke something. (if the <code>pipeline.yaml</code> file is modified)</p>"},{"location":"cicd/#using-a-makefile","title":"Using a Makefile","text":"<p>When you use YS to generate your YAML files, you'll only be editing the YS files but you need to make sure that the YAML files are always up to date.</p> <p>There are many ways to do this, but one simple way is to use a Makefile.</p> <p>Here is an example Makefile that will generate any files in your project that end in <code>.ys</code> from the corresponding <code>.yaml</code> file:</p> <pre><code>SHELL := bash\n\nYS_VERSION := 0.1.95\nYS := /tmp/bin/ys-$(YS_VERSION)\nYS_FILES := $(shell find . -name '*.ys')\nYAML_FILES := $(YS_FILES:.ys=.yaml)\n\nupdate: $(YAML_FILES)\n\ntest: update\n        @git diff --quiet --exit-code -- $(YAML_FILES) || { \\\n          git diff -- $(YAML_FILES); \\\n          echo \"ERROR: YAML files are out of date\"; \\\n          echo \"Run 'make update' to update them\"; \\\n          exit 1; \\\n          }\n        @echo \"PASS: All YAML files are up to date\"\n\n%.yaml: %.ys $(YS) Makefile\n        @echo \"# GENERATED FILE. EDIT '$&lt;' INSTEAD.\" &gt; $@.tmp\n        $(YS) -Y $&lt; &gt;&gt; $@.tmp\n        mv $@.tmp $@\n\n$(YS):\n        curl -s https://getys.org/ys | \\\n          PREFIX=/tmp VERSION=$(YS_VERSION) QUIET=1 bash \\\n          &gt; /dev/null\n\n.PHONY: update test\n</code></pre> <p>Every time you change a <code>.ys</code> file, you can run <code>make test</code> to make sure that the corresponding <code>.yaml</code> file is up to date. You'll see a diff of the changes if there are any. If you are refactoring your <code>.ys</code> file, you can run <code>make update</code> to make sure nothing has changed in the <code>.yaml</code> files.</p> <p>Note</p> <p>Notice how the Makefile adds a comment to remind you that the <code>.yaml</code> files are generated and should not be edited directly.</p> <p>This Makefile even downloads the <code>ys</code> binary for you, so you don't need to have it pre-installed on your system. In fact it installs a specific version of <code>ys</code> so you can be assured that the generated YAML files are always the same.</p>"},{"location":"cicd/#using-a-git-hook","title":"Using a Git hook","text":"<p>You can add a Git pre-push hook to make sure that the <code>.yaml</code> files are up to date before you push your changes.</p> <p>If the updated <code>.yaml</code> files have changed, the commit will be aborted and you'll need to commit the changes before you can push.</p>"},{"location":"circleci/","title":"YS and CircleCI","text":"<p>Calva\u00a0  is an integrated development environment for enjoyable and productive Clojure\u00a0  and ClojureScript\u00a0  programming in Visual Studio Code\u00a0 .</p> <p>Calva uses CircleCI\u00a0  for continuous integration and deployment. CircleCI requires a <code>.circleci/config.yml</code> file to define the build and deployment steps.</p> <p>YS  Calva</p> <p>Nearly all of the YS Project's\u00a0  code was written using Calva. It's by far the best way to develop software with Clojure.</p> <p>Calva's <code>config.yml</code> file had grown to be quite large and complex, but after refactoring it to use YS\u00a0 , it is now much more maintainable and easier to work with.</p> <p>What started out as one big 636 line YAML file\u00a0  with lots of embedded Bash scripts, was refactored into nearly 40 small files\u00a0  each with a clear and specific purpose.</p> <p>You can see the how the migration was made over 30 single purpose commits in this Pull Request\u00a0 .</p> <p>Now changes are made in a much more maintainable way, and the CircleCI required <code>config.yml</code> file is generated from the YS files using a simple <code>ys</code> command:</p> <pre><code>$ ys -Y config.ys &gt; config.yml\n</code></pre> <p>As a bonus, linting was performed on the Bash scripts (now in their own files) and several small issues were found and fixed.</p> <p>This technique is a general strategy for refactoring large YAML files into smaller, more maintainable ones, regardless of whether or not the target system uses YS natively yet.</p>"},{"location":"contrib-roadmap/","title":"The YS Road Map","text":"<p>While the YS language is quite capable today for both extending YAML files and general programming, there is still a seemingly endless list of things that should be done to improve the language, its libraries, and full integration with with the world of data and code.</p>"},{"location":"contrib-roadmap/#ys-language-bindings","title":"YS Language Bindings","text":"<p>YS YAML loaders have major advantages over the existing YAML loaders:</p> <ul> <li>Same API and capabilities regardless of the language.</li> <li>T </li> <li>Highly configurable.</li> </ul>"},{"location":"contrib-rules/","title":"Contribution Guidelines","text":""},{"location":"contrib-rules/#please-and-thank-you","title":"Please and Thank You","text":"<p>YS is an Open Source project, and we need your help!</p>"},{"location":"contrib-website/","title":"Website Contribution","text":""},{"location":"contrib-website/#please-and-thank-you","title":"Please and Thank You","text":"<p>The YS website needs your help! Especially with the documentation.</p> <p>Everyone is welcome to contribute to the website, and your contributions are greatly appreciated.</p>"},{"location":"contrib-website/#about-this-website","title":"About this Website","text":"<p>Read This Page to learn how this website combined Material for MkDocs with YS to make a site that is super easy to contribute to.</p>"},{"location":"contrib-website/#how-to-contribute","title":"How to Contribute","text":"<p>The yamlscript.org website is designed to be very easy to contribute to.</p> <p>Every single page on the site is created from a Markdown file in the YS repository\u00a0 . This repo is a mono-repo, meaning that all parts of the YS project is in there.</p> <p>Also, every page in the site (except the front page) has a \"view source\" button and an \"edit this page\" button. These buttons will take you to the source file for that page.</p> <p>The \"edit\" button will drop you into the GitHub editor for that page. You can make your changes and then submit a pull request.</p> <p>This is the easiest way to contribute to the site for small changes.</p>"},{"location":"contrib-website/#bigger-changes","title":"Bigger Changes","text":"<p>If you want to add new pages of content, or make more significant changes, you should clone the repo and work on it locally. When you are ready to submit your changes, you can create a pull request.</p> <p>Testing your changes locally is incredibly easy. To get started, run thesee commands:</p> <pre><code>$ git clone https://github.com/yaml/yamlscript\n$ cd yamlscript\n$ git checkout website  # PRs should be made against the \"website\" branch\n$ cd www\n$ make serve\n</code></pre> <p>The <code>make serve</code> command will install all the dependencies in the <code>./.venv/</code> and in <code>/tmp/yamlscript/</code> and then start a local webserver at http://localhost:8000\u00a0 .</p> <p>It will aslo start a watcher that will automatically rebuild the site when you make changes to the source files. These  changes will be visible in your browser immediately.</p>"},{"location":"contrib-website/#important-source-files","title":"Important Source Files","text":"<p>The YS website\u00a0  is built using the Material for MkDocs\u00a0  statis site framework, which is quite incredible in terms of what it can do (and easily).</p> <p>Note</p> <p>You don't need to know anything about MkDocs to make changes to the site, but if you want to add plugins or make theme customizations, you will need to learn a bit.</p> <p>The prerequisites for building the site are very minimal:</p> <ul> <li>Linux or MacOS</li> <li>Python 3.6+</li> <li>Python <code>pip</code></li> <li>GNU <code>make</code></li> <li><code>curl</code></li> <li><code>bash</code></li> </ul> <p>Note</p> <p>The <code>bash</code> command just needs to be found in your <code>PATH</code>; it doesn't need to be your interactive shell. In other words, you can do development work on this site from from a terminal using <code>zsh</code>, <code>fish</code>, or whatever shell you prefer.</p> <p>The most important files for the website are:</p> <ul> <li><code>www/Makefile</code> - This <code>Makefile</code> is used to handle all the various   orchestration tasks you may need to do.</li> <li><code>www/config.ys</code> - The main configuration file for the site. Written in YS.</li> <li><code>www/config/</code> - The YAML config files for various aspects of the site.</li> <li><code>www/src/</code> - The source files for the site.</li> <li><code>doc/</code> - The source files for the documentation.</li> <li><code>blog/</code> - The source files for the blog.</li> <li><code>www/requirements.txt</code> - The Python requirements for the site.</li> <li><code>www/theme/**</code> - The theme override files for the site.</li> </ul>"},{"location":"contrib-website/#ask-us-for-help","title":"Ask Us for Help","text":"<p>If you need help with anything, start a discussion here\u00a0 .</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"How do you pronounce YS? <p>We like to say \"wise\" since its how you might pronounce the plural of \"Y\".  You can also say \"why-ess\" for \"Y S\" or the long name for YS: \"YAMLScript\" (\"YAML (rhymes with camel) Script\").</p> <p>YS has many side projects like HelmYS (\"helm-wise\") or SchemaYS (\"schema-wise\").</p> Is YS really YAML? <p>Yes. Empirically. The YS compiler has 7 stages (phases) to transform YS (YAML) into Clojure. The first phase is call <code>parse</code> and it currently uses the SnakeYAML Engine parser\u00a0  code for this process.</p> Who created YS? <p>YS was created by Ingy d\u00f6t Net, a founding creator and current maintainer of the YAML Data Language\u00a0 .</p> What is the preferred file extension for YS files? <p>The preferred file extension for YS files is <code>.ys</code>, but you can use <code>.yaml</code> or <code>.yml</code> if you prefer for most files. The <code>ys</code> command line tool doesn't look at the file extension and will treat them all the same.</p> <p>If you are enhancing an existing YAML file, there is no need to change the file extension to <code>.ys</code>. You can just start using YS features in the file.</p> <p>On the other hand, YS libraries loaded with the <code>use</code> function are required to have the <code>.ys</code> extension.</p> Clojure is a JVM language. Does YS need the JVM? <p>No. YS is written in Clojure and exposes the Clojure/Java runtime ecosystem, but there is no JVM involved. This is thanks to the GraalVM\u00a0  project's native-image\u00a0  which can compile anything compiled to jar files into a standalone native binary executable or shared library.</p> <p>This is how the <code>ys</code> binary and the <code>libyamlscript.so</code> shared library are created.</p> <p>Note</p> <p>Even the YS build system does not require you to have any Java or Clojure stuff installed. It simply downloads a GraalVM tarball into <code>/tmp</code>, and the Makefile takes care of everything without leaving any mess behind.</p> Do I need to know Clojure to use YS? <p>All YS/YAML code is compiled to Clojure and evaluated when you run or load it.</p> <p>That said, you can get pretty far with YS without knowing any Clojure. Just read the docs and look at the examples.</p> <p>To become a YS expert, you will need to know Clojure (and YAML) well.</p>"},{"location":"gha/","title":"YS and GitHub Actions","text":"<p>RapidYAML\u00a0  is the world's fastest and most correct YAML parser written in C++.</p> <p>It uses GitHub Actions (GHA)\u00a0  workflows to build and test the codebase for a variety of platforms and configurations.</p> <p>The YAML files for these workflows are have been converted to YS\u00a0  resulting in a much more concise, maintainable and readable set of workflows files (that do exactly the same thing as before).</p> <p>GitHub Actions is a really well thought out system for using YAML as a language to define CI/CD workflows. That said, YS can be used to make these workflows cleaner and more enjoyable to work with.</p> <p>RapidYAML coming to YS Soon</p> <p>The YS and RapidYAML authors have been working together to bring the power of RapidYAML to the YS compiler. Currently the YS compiler uses SnakeYAML Engine\u00a0  (which is quite good) for its parsing stage. We hope that by offering RapidYAML as an option, we can make YS even faster and more correct.</p>"},{"location":"hacks/","title":"YS Hacks","text":"<p>Here are some interesting real-world hacks that have been done with YS.</p> <ul> <li>GitHub Gist \u2014 Post GitHub Gists from the command line.</li> <li>YAMLLM \u2014 a command line tool to query common LLM APIs.</li> </ul>"},{"location":"helmys/","title":"HelmYS - YS Helm Charts","text":"<p>HelmYS\u00a0  is a Kubernetes Helm\u00a0 \"post renderer\"\u00a0  that lets you write your Helm chart templates with YS.</p> Click here for how to install <code>helmys</code> and <code>ys</code> quickly <p>Run these commands to install <code>helmys</code> and <code>ys</code> in <code>~/.local/bin</code>:</p> <pre><code>git clone https://github.com/kubeys/helmys\nmake -C helmys install PREFIX=$HOME/.local\n</code></pre> <p>Full details here\u00a0 .</p> <p>YS can be used in combination with Helm's standard Go template\u00a0  syntax or it can replace it entirely.</p> <p>When YS is used exclusively, the Helm chart templates are not only simpler and more concise, but they are also valid YAML files (just like the <code>Chart.yaml</code> and <code>values.yaml</code> files). That means they can be processed with any YAML tools, such as being validated with a YAML linter like yamllint\u00a0 .</p>"},{"location":"helmys/#template-file-comparisons","title":"Template File Comparisons","text":"<p>This is a side by side comparison of the Helm chart template YAML files created by <code>helm create &lt;chart-name&gt;</code> and then converted to use YS. The left side is the YS version and the right side is the original Go template version.</p> ys-chart/templates/helpers.yaml<pre><code>!YS-v0\ndefn trunc(s): take(63 s).str(*).replace(/-$/)\n\n# Expand the name of the chart:\nchart-name =:\n  trunc: Values.nameOverride ||| Chart.name\n\n# Create a default fully qualified app name.\nchart-fullname =:\n  if Values.fullnameOverride.?:\n    trunc: Values.fullnameOverride\n    else:\n      name =: Values.nameOverride ||| Chart.name\n      if name.has?(Release.Name):\n        trunc: Release.Name\n        format \"%s-%s\": Release.Name name\n\n# Selector labels:\nselectorLabels =::\n  app.kubernetes.io/name:: Chart.name\n  app.kubernetes.io/instance:: Release.Name\n\n# Chart labels:\nchart-labels =::\n  helm.sh/chart:: \"$(Chart.name)-$(Chart.version)\"\n  :: selectorLabels\n  app.kubernetes.io/version:: Chart.appVersion\n  app.kubernetes.io/managed-by:: Release.Service\n\n# Create the name of the service account to use:\nserviceAccountName =:\n  Values.serviceAccount.name |||:\n    if Values.serviceAccount.create:\n      chart-fullname\n      'default'\n</code></pre> go-chart/templates/_helpers.tpl<pre><code>{{/*\nExpand the name of the chart.\n*/}}\n{{- define \"go-chart.name\" -}}\n{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix \"-\" }}\n{{- end }}\n\n{{/*\nCreate a default fully qualified app name.\nWe truncate at 63 chars because some Kubernetes name fields are limited to\nthis (by the DNS naming spec).\nIf release name contains chart name it will be used as a full name.\n*/}}\n{{- define \"go-chart.fullname\" -}}\n{{- if .Values.fullnameOverride }}\n{{- .Values.fullnameOverride | trunc 63 | trimSuffix \"-\" }}\n{{- else }}\n{{- $name := default .Chart.Name .Values.nameOverride }}\n{{- if contains $name .Release.Name }}\n{{- .Release.Name | trunc 63 | trimSuffix \"-\" }}\n{{- else }}\n{{- printf \"%s-%s\" .Release.Name $name | trunc 63 | trimSuffix \"-\" }}\n{{- end }}\n{{- end }}\n{{- end }}\n\n{{/*\nCreate chart name and version as used by the chart label.\n*/}}\n{{- define \"go-chart.chart\" -}}\n{{- printf \"%s-%s\" .Chart.Name .Chart.Version | replace \"+\" \"_\" | trunc 63 |\n    trimSuffix \"-\" }}\n{{- end }}\n\n{{/*\nCommon labels\n*/}}\n{{- define \"go-chart.labels\" -}}\nhelm.sh/chart: {{ include \"go-chart.chart\" . }}\n{{ include \"go-chart.selectorLabels\" . }}\n{{- if .Chart.AppVersion }}\napp.kubernetes.io/version: {{ .Chart.AppVersion | quote }}\n{{- end }}\napp.kubernetes.io/managed-by: {{ .Release.Service }}\n{{- end }}\n\n{{/*\nSelector labels\n*/}}\n{{- define \"go-chart.selectorLabels\" -}}\napp.kubernetes.io/name: {{ include \"go-chart.name\" . }}\napp.kubernetes.io/instance: {{ .Release.Name }}\n{{- end }}\n\n{{/*\nCreate the name of the service account to use\n*/}}\n{{- define \"go-chart.serviceAccountName\" -}}\n{{- if .Values.serviceAccount.create }}\n{{- default (include \"go-chart.fullname\" .) .Values.serviceAccount.name }}\n{{- else }}\n{{- default \"default\" .Values.serviceAccount.name }}\n{{- end }}\n{{- end }}\n</code></pre> ys-chart/templates/deployment.yaml<pre><code>!YS-v0:\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name:: chart-fullname\n  labels:: chart-labels\nspec:\n  :when-not Values.autoscaling.enabled.?::\n   replicas:: Values.replicaCount\n  selector:\n    matchLabels:: selectorLabels\n  template:\n    metadata:\n      :when+ Values.podAnnotations.?::\n       annotations:: _\n      labels:: chart-labels\n    spec:\n      :when+ Values.imagePullSecrets.?::\n       imagePullSecrets:: _\n      serviceAccountName:: serviceAccountName\n      securityContext:: Values.podSecurityContext\n      containers:\n      - name:: Chart.name\n        securityContext:: Values.securityContext\n        image::\n          \"$(Values.image.repository):\\\n           $(Values.image.tag ||| Chart.appVersion)\"\n        imagePullPolicy:: Values.image.pullPolicy\n        ports:\n        - name: http\n          containerPort:: Values.service.port\n          protocol: TCP\n        livenessProbe:: Values.livenessProbe\n        readinessProbe:: Values.readinessProbe\n        resources:: Values.resources\n        :when+ Values.volumeMounts.?::\n         volumeMounts:: _\n      :when+ Values.volumes.?::      {volumes:: _}\n      :when+ Values.nodeSelector.?:: {nodeSelector:: _}\n      :when+ Values.affinity.?::     {affinity:: _}\n      :when+ Values.tolerations.?::  {tolerations:: _}\n</code></pre> go-chart/templates/deployment.yaml<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: {{ include \"go-chart.fullname\" . }}\n  labels:\n    {{- include \"go-chart.labels\" . | nindent 4 }}\nspec:\n  {{- if not .Values.autoscaling.enabled }}\n  replicas: {{ .Values.replicaCount }}\n  {{- end }}\n  selector:\n    matchLabels:\n      {{- include \"go-chart.selectorLabels\" . | nindent 6 }}\n  template:\n    metadata:\n      {{- with .Values.podAnnotations }}\n      annotations:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      labels:\n        {{- include \"go-chart.labels\" . | nindent 8 }}\n        {{- with .Values.podLabels }}\n        {{- toYaml . | nindent 8 }}\n        {{- end }}\n    spec:\n      {{- with .Values.imagePullSecrets }}\n      imagePullSecrets:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      serviceAccountName: {{ include \"go-chart.serviceAccountName\" . }}\n      securityContext:\n        {{- toYaml .Values.podSecurityContext | nindent 8 }}\n      containers:\n        - name: {{ .Chart.Name }}\n          securityContext:\n            {{- toYaml .Values.securityContext | nindent 12 }}\n          image: \"{{ .Values.image.repository }}:{{ .Values.image.tag |\n                     default .Chart.AppVersion }}\"\n          imagePullPolicy: {{ .Values.image.pullPolicy }}\n          ports:\n            - name: http\n              containerPort: {{ .Values.service.port }}\n              protocol: TCP\n          livenessProbe:\n            {{- toYaml .Values.livenessProbe | nindent 12 }}\n          readinessProbe:\n            {{- toYaml .Values.readinessProbe | nindent 12 }}\n          resources:\n            {{- toYaml .Values.resources | nindent 12 }}\n          {{- with .Values.volumeMounts }}\n          volumeMounts:\n            {{- toYaml . | nindent 12 }}\n          {{- end }}\n      {{- with .Values.volumes }}\n      volumes:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      {{- with .Values.nodeSelector }}\n      nodeSelector:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      {{- with .Values.affinity }}\n      affinity:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      {{- with .Values.tolerations }}\n      tolerations:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n</code></pre> ys-chart/templates/serviceaccount.yaml<pre><code>!YS-v0:\n:when Values.serviceAccount.create:\n  apiVersion: v1\n  kind: ServiceAccount\n  metadata:\n    name:: serviceAccountName\n    labels:: chart-labels\n    :when+ Values.serviceAccount.annotations.?::\n     annotations:: _\n  automountServiceAccountToken::\n    Values.serviceAccount.automount\n</code></pre> go-chart/templates/serviceaccount.yaml<pre><code>{{- if .Values.serviceAccount.create -}}\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: {{ include \"go-chart.serviceAccountName\" . }}\n  labels:\n    {{- include \"go-chart.labels\" . | nindent 4 }}\n  {{- with .Values.serviceAccount.annotations }}\n  annotations:\n    {{- toYaml . | nindent 4 }}\n  {{- end }}\nautomountServiceAccountToken: {{ .Values.serviceAccount.automount }}\n{{- end }}\n</code></pre> ys-chart/templates/service.yaml<pre><code>!YS-v0:\napiVersion: v1\nkind: Service\nmetadata:\n  name:: chart-fullname\n  labels:: chart-labels\nspec:\n  type:: Values.service.type\n  ports:\n  - port:: Values.service.port\n    targetPort: http\n    protocol: TCP\n    name: http\n  selector:: selectorLabels\n</code></pre> go-chart/templates/service.yaml<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: {{ include \"go-chart.fullname\" . }}\n  labels:\n    {{- include \"go-chart.labels\" . | nindent 4 }}\nspec:\n  type: {{ .Values.service.type }}\n  ports:\n    - port: {{ .Values.service.port }}\n      targetPort: http\n      protocol: TCP\n      name: http\n  selector:\n    {{- include \"go-chart.selectorLabels\" . | nindent 4 }}\n</code></pre>"},{"location":"ingydotnet/","title":"About Ingy d\u00f6t Net","text":"<p>Ingy d\u00f6t Net is a software developer and speaker. He is best known for his work on the YAML\u00a0  data serialization language.</p> <p>Recently Ingy created the YS programming language, which embeds cleanly into YAML, adding the functional features that many YAML users need.</p>"},{"location":"ingydotnet/#contact-ingy","title":"Contact Ingy","text":"<ul> <li>Email: ingy@ingy.net</li> <li>LinkedIn: https://www.linkedin.com/in/ingydotnet\u00a0 </li> <li>GitHub: https://github.com/ingydotnet\u00a0 </li> <li>Matrix: https://matrix.to/#/@ingy:yaml.io\u00a0  (best way to chat w/ Ingy)</li> <li>Slack: https://kubernetes.slack.com/team/U080RUYTQL8\u00a0 </li> <li>BlueSky: https://bsky.app/profile/ingydotnet.bsky.social\u00a0 </li> <li>Mastodon: https://mastodon.cloud/@ingydotnet\u00a0 </li> </ul>"},{"location":"ingydotnet/#hire-ingy","title":"Hire Ingy","text":"<p>Ingy\u00a0  is available for consulting, training, and speaking engagements worldwide on YS, YAML, and other related topics.</p>"},{"location":"json/","title":"JSON is YAML!","text":"<p>Since YAML 1.2\u00a0  (2009) JSON is a complete subset of YAML. This means that any valid JSON file is also a valid YAML file and can be loaded by a YAML loader to produce the equivalent data structure as if it were loaded by a JSON parser.</p> <p>Since YS is a YAML loader it can used on JSON files as well.</p> <p>This is very useful for converting between the two formats and for using YS to query and transform JSON files.</p> <p>Note</p> <p>Just because the YAML spec says it's a subset doesn't mean that all YAML tools can be trusted to handle JSON files 100% correctly. Caveat emptor.</p>"},{"location":"kubeys24/","title":"KubeCon 2024 YS Tutorial Info Page","text":"<p>This page has info from Ingy d\u00f6t Net's YS tutorial at KubeCon 2024 in Salt Lake City\u00a0 .</p> <ul> <li>Ingy d\u00f6t Net\u00a0 </li> <li>Video\u00a0 </li> <li>Slides\u00a0 </li> <li>YS Documentation\u00a0 </li> <li>YS Blog\u00a0 </li> <li>YS Repository\u00a0 </li> <li>YS on Exercism\u00a0 </li> <li>HelmYS Helm Templating\u00a0 </li> <li>YS on Rosetta Code\u00a0 </li> <li>RosettaCodeData Repository\u00a0 </li> <li>Calva CircleCI Refactor\u00a0 </li> <li>Vroom Slides in Vim\u00a0 </li> </ul> <p></p> <ul> <li>Programs written in YS</li> <li>sbs\u00a0      Creates markdown gists to compare pairs of files side by side. Used to show     differences between YS and Go templates in Helm.<ul> <li>Example HelmYS gist\u00a0 </li> </ul> </li> <li>yamllm\u00a0      A command line multi LLM (Anthropic, OpenAI, Gemma) query tool</li> <li>ys-vs-rc\u00a0      Compares YS and Rosetta Code solutions to the same problem in many     languages.<ul> <li>Example FizzBuzz gist\u00a0 </li> </ul> </li> <li>See YS by Example in the YS documentation for more     examples.</li> </ul>"},{"location":"kubeys24/#tutorial-outline","title":"Tutorial Outline","text":"<ul> <li>Ingy d\u00f6t Net</li> <li>Introducing YAMLScript (aka YS)</li> <li>Rosetta Code</li> <li>Programming in YAMLScript</li> <li>Real Programming in YAMLScript</li> <li>Bash style -x trace debugging in YAMLScript</li> <li>YAMLScript Improves YAML</li> <li>Learn YAMLScript at Exercism</li> <li>Replacing YAML's &lt;&lt; Merge Key</li> <li>YAMLScript Modes</li> <li>Dot Chains in YAMLScript One-Liners</li> <li>Refactoring large messy YAML configs</li> <li>Refactoring Calva's CircleCI Config</li> <li>Using YAMLScript in Helm Charts</li> <li>YAMLScript's Built-in Standard Libraries</li> <li>Accessing External Data in Data Mode</li> <li>Compiling YAMLScript programs to binary executables</li> <li>Installing YAMLScript</li> <li>Replace your YAML Loader with YAMLScript</li> <li>How YAMLScript (&amp; YAML Loaders) Work</li> <li>Learn Lisp and Clojure in One Minute</li> <li>Learning YAMLScript in Reverse</li> </ul>"},{"location":"kubeys24/#contributing-to-ys","title":"Contributing to YS","text":"<p>YS is a young language and we are looking for contributors to help improve the language, the documentation, and the ecosystem. We welcome your contributions!</p>"},{"location":"kubeys24/#funding-ys-and-yaml","title":"Funding YS and YAML","text":"<p>YS is a free and open source programming language. If you would like to help fund the development of YS, please consider becoming a YS sponsor.</p> <p>Reach out to Ingy about this.</p>"},{"location":"kubeys24/#hire-ingy","title":"Hire Ingy","text":"<p>Ingy\u00a0  is available for consulting, training, and speaking engagements worldwide on YS, YAML, and other related topics.</p>"},{"location":"play/","title":"Playing with YS","text":""},{"location":"play/#coming-soon","title":"Coming Soon!","text":"<p>We are working on a fun and interactive way to play with YS. Stay tuned!</p>"},{"location":"press/","title":"Press","text":""},{"location":"press/#ys-in-the-news","title":"YS in the News","text":"<ul> <li>YS Releases\u00a0 </li> <li>YAML Becomes a Proper Programming Language\u00a0 </li> </ul>"},{"location":"press/#podcasts","title":"PodCasts","text":"<ul> <li>Dead Code \u2014 February 11, 2025\u00a0 </li> <li>The REPL \u2014 April 15, 2024\u00a0 </li> </ul>"},{"location":"press/#presentation-videos","title":"Presentation Videos","text":"<ul> <li>Tutorial: Simplify and Optimize Your YAML with YAMLScript\u00a0  --   Ingy's tutorial at KubeCon 2024 in Salt Lake City</li> <li>YAMLScript - Scripting in YAML\u00a0  --   Ingy at the 2024 TPRC in Las Vegas</li> <li>YAML and YAMLScript\u00a0  --   Ingy at Open Source Summit North America 2024 in Seattle</li> <li>Seajure March 2024 - YAMLScript\u00a0 </li> </ul>"},{"location":"site-testing/","title":"Nothing to see here...","text":"<ul> <li>Social Card for main page</li> </ul>"},{"location":"social/","title":"Social YS","text":"<p>Here are some places where you can engage with the YS Community:</p> <ul> <li>YS GitHub Discussions\u00a0 </li> <li>YS Matrix Chat\u00a0 </li> <li>YS in Clojurians Slack\u00a0 </li> <li>YS on IRC\u00a0 </li> </ul>"},{"location":"tprc2024/","title":"TPRC 2024 YS Talks","text":""},{"location":"tprc2024/#tprc-2024-ingys-ys-talks-info","title":"TPRC 2024 Ingy's YS Talks Info","text":"<p>This web page has info to help you follow along with the YS talks at The Perl and Raku Conference 2024 in Las Vegas.</p>"},{"location":"tprc2024/#quick-links-for-ys","title":"Quick Links for YS","text":"<ul> <li>Talks Assets\u00a0 </li> <li>Talk Slide Files:</li> <li>YAMLScript \u2014 Scripting in YAML\u00a0 </li> <li>YAMLScript \u2014 Dynamic YAML in Perl and Raku\u00a0 </li> <li>Introduction to Clojure for Perl Programmers\u00a0 </li> <li>YS Repository\u00a0 </li> <li>YS Web Site\u00a0 </li> <li>YS Blog\u00a0 </li> <li>YS Docs\u00a0 </li> <li>Clojurians' Slack #yamlscript Channel\u00a0 </li> <li>Matrix #chat-yamlscript Room\u00a0 </li> </ul>"},{"location":"tprc2024/#contact-ingy-dot-net","title":"Contact Ingy d\u00f6t Net","text":"<ul> <li>Matrix DM\u00a0 </li> <li>Slack DM\u00a0 </li> <li>GitHub\u00a0 </li> <li>Email\u00a0\u2709</li> </ul>"},{"location":"tprc2024/#quick-install-for-ys-and-libyamlscriptso","title":"Quick Install For ys and libyamlscript.so","text":"<p>YS works on Linux and macOS. Not on Windows yet.</p> <p>Install ys and libyamlscript.so (in <code>~/.local/bin</code> and <code>~/.local/lib</code>): <pre><code>curl -s https://yamlscript.org/install | bash\n</code></pre></p> <p>Run that as root installs under <code>PREFIX=/usr/local</code>.</p> <p>Install into different directory <code>... | PREFIX=/other/dir bash</code>. Install specific version <code>... | VERSION=0.1.xx bash</code>.</p>"},{"location":"tprc2024/#install-from-source","title":"Install from Source","text":"<p>If the quick install has problems, you can usually get it to work by building from source.</p> <pre><code>git clone https://github.com/yaml/yamlscript\ncd yamlscript\nmake install\n</code></pre> <p>The only dependencies are <code>git</code>, <code>curl</code>, <code>bash</code> and <code>make</code>. Also a <code>libz-dev</code> package is required on Linux.</p>"},{"location":"tprc2024/#install-the-language-modules","title":"Install the Language Modules","text":"<pre><code>cpanm YAMLScript\nzef install YAMLScript\npip install yamlscript\nnpm install @yaml/yamlscript\ngem install yamlscript\n</code></pre> <p>Also you'll need to have <code>libyamlscript.so</code> installed. See above.</p>"},{"location":"blog/","title":"Index","text":"<p>RSS Feed</p>"},{"location":"blog/#the-ys-blog","title":"The YS Blog","text":""},{"location":"community/","title":"YS Community","text":"<p>YS is a community-driven, Open Source Programming Language, with a focus on making YAML better everywhere.</p> <p>While YS is a \"full\" programming language, it is far from complete. There's so much interesting stuff to work on. We welcome your participation and contributions.</p> <p>Here are some ways you can get involved:</p> <ul> <li>Be Social</li> <li>Improve the Docs</li> <li>Contribute to YS</li> </ul>"},{"location":"contrib/","title":"Contribute to YS","text":"<p>YS is an open-source project and we welcome contributions from the community. There are many ways to contribute, from writing tutorials or blog posts, improving the documentation, submitting bug reports and feature requests or writing code which can be incorporated into YS itself.</p> <p>Want to help out with YS? Great! Here are some ways you can contribute:</p> <ul> <li>Use YS \u2014   The more people that use YS, the more feedback we get, and the better   the language becomes.</li> <li>Report Bugs\u00a0  \u2014   If you find a bug in YS, please report it.</li> <li>Request Features\u00a0  \u2014   If you have an idea for a feature in YS, please let us know.</li> <li> <p>Submit Pull Requests \u2014   If you know your way around Clojure\u00a0  a bit (or are willing to learn),   try improving YS by submitting a code pull request.</p> <p>Adding a new function or fixing a bug in the YS Standard Library\u00a0  is a great way to start.</p> </li> <li> <p>Write Documentation \u2014   Go here to learn how to contribute to the YS documentation.</p> </li> <li>Write Tests \u2014   Have a look at these tests:<ul> <li>YS Compiler/Core Tests\u00a0 </li> <li>YS Runtime Tests\u00a0 </li> </ul> </li> </ul> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"doc/","title":"Welcome to the YS Documentation","text":"<p>YS is a still a fairly new language, and this documentation is a work in progress.</p> <p>While we hope that you find the information you came looking for here, we know that there are still many gaps in the documentation.</p> <p>The good news is \"You Can Help!\".</p> <p>Writing great documentation is a team effort, and we are trying to make it as easy as possible for you to contribute.</p> <p>Almost every page on this site (including this one!!) has an \"Edit this page\" button at the top:</p> <p></p> <p>As you read the documentation, if you find a typo or something that is unclear, you can click the \"Edit this page\" button, make the changes, and submit a pull request.</p> <p>Furthermore, most pages (and all the documentation pages) have a \"Discuss this page\" button at the top:</p> <p></p> <p>If you have ideas on how to improve the page or have questions about the content, this will take you to a YS GitHub Discussions\u00a0  discussion about the page (or to instructions on how to start a new discussion for a page that doesn't have one yet).</p> <p>We look forward to this YS journey together and hope that you will help us make the documentation the best it can be!</p>"},{"location":"doc/4clojure/","title":"YS for Clojurians","text":"<p>If you happen to already be fluent in the Clojure programming language, you have a huge head start for learning YS; at least for reading and understanding YS code.</p> <p>For the most part understanding YS code is a matter is simply understanding a bunch of simple transformations that turn it into Clojure code.</p> <p>This page will cover most of the transformations you'll need to know.</p> <p>Note</p> <p>After reading this page, you should be able to read YS code and also be able write working YS code fairly easily. To write really good, idiomatic YS code, you should also be well versed in all the various YAML forms, and when to best use them. Like anything, practice makes perfect!</p>"},{"location":"doc/4clojure/#foreword","title":"Foreword","text":"<p>YS is a language made from a combination of YAML and Clojure, and its design tries to combine the best of both worlds. This might seem like a bad idea at first, but it actually works out surprisingly well.</p> <p>YS interpreter (compiler and runtime) is:</p> <ul> <li>Written in Clojure</li> <li>Compiles to Clojure code</li> <li>Evaluates with a Clojure runtime</li> </ul> <p>But the primary YS audience is not Clojure programmers! While YS is a complete programming language, and can be used for any task in general, it will likely be most useful for people who need more from their YAML. All YAML config files are valid YS code and YS code is always 100% valid YAML.</p> <p>This document is not an attempt to convert Clojure programmers to YS. It is simply meant to help people learn YS faster if they already know Clojure.</p>"},{"location":"doc/4clojure/#syntax-intro","title":"Syntax Intro","text":"<p>Clojure is a Lisp. Lisp code is comprised of list forms, value forms, comments and whitespace. Clojure has a somewhat richer syntax than your typical Lisp, adding brackets and braces for some forms and reader macros for others. Still, structurally there is very little to learn.</p> <p>YAML code is a data language that unlike JSON or EDN offers quite a few syntactic constructs like comments, anchors, aliases, tags, block (indented) and flow (bracketed) collections styles and 5 different scalar quoting styles: plain (unquoted), single quoted, double quoted, literal and folded.</p> <p>YS makes use of all of these constructs to make a clean looking programming language that simultaneously works as a data language.</p> <p>The main takeaway here is that YS offers a lot more flexibility in ways to write code than Clojure (Lisp) does.</p> <p>Note</p> <p>Whether \"more\" ways is better or worse is entirely up to you. It's just important to point out from the start that YS has this flexibility and you should expect to see it in the code.</p>"},{"location":"doc/binary/","title":"Compiling YS to Binary","text":"<p>You can compile any YS program that has a <code>main</code> function to a machine native binary executable.</p> <p>This is done using the <code>ys --compile --binary</code> command.</p> <p>For example, if you have a file named <code>hello.ys</code> with the following content:</p> <pre><code>!YS-v0\n\ndefn main(name='world'):\n  say: 'Hello, $name!'\n</code></pre> <p>You can run:</p> <pre><code>$ time ys --compile --binary hello.ys\n* Compiling YS 'hello.ys' to 'hello' executable\n* Setting up build env in '/tmp/tmp.W0u4SGljdY'\n* This may take a few minutes...\n[1/8] Initializing              (3.1s @ 0.24GB)\n[2/8] Performing analysis               (12.2s @ 0.64GB)\n[3/8] Building universe         (1.8s @ 0.45GB)\n[4/8] Parsing methods           (1.6s @ 0.46GB)\n[5/8] Inlining methods          (1.4s @ 0.63GB)\n[6/8] Compiling methods         (17.7s @ 0.43GB)\n[7/8] Laying out methods                (1.0s @ 0.49GB)\n[8/8] Creating image            (1.7s @ 0.54GB)\n* Compiled YS 'hello.ys' to 'hello' executable\n\nreal    0m48.929s\nuser    6m44.965s\nsys     0m5.095s\n$ ls -lh hello\n-rwxr-xr-x 1 me me 13M Sep 10 15:04 hello*\n</code></pre> <p>Note that the compilation takes some time and the resulting binary is quite large.</p> <p>Let's try it out:</p> <pre><code>$ time ./hello\nHello, world!\n\nreal    0m0.014s\nuser    0m0.002s\nsys     0m0.013s\n$ time ./hello Bob\nHello, Bob!\n\nreal    0m0.014s\nuser    0m0.005s\nsys     0m0.010s\n</code></pre> <p>Let's compare the 14ms runtime to using the <code>ys</code> interpreter with <code>-e</code>:</p> <pre><code>$ time ys -e 'defn main(name=\"world\"): say(\"Hello, $name!\")'\nHello, world!\n\nreal    0m0.034s\nuser    0m0.019s\nsys     0m0.017s\n</code></pre> <p>The binary is about 2.5 times faster than the interpreter in this case.</p> <p>Note that we can even compile the one-liner if we want to:</p> <pre><code>$ ys --compile --binary -e 'defn main(name=\"world\"): say(\"Hello, $name!\")'\n... time passes ...\n* Compiled YS '-e' to './NO-NAME' executable\n</code></pre> <p>Since there is no input file, the binary is named <code>NO-NAME</code>.</p> <p>Optionally, you can use the <code>--output=&lt;file-name&gt;</code> to specify the output file name.</p> <p>The options listed above have short names as well:</p> <pre><code>$ ys -cbo say-hi hello.ys\n* Compiling YS 'hello.ys' to 'say-hi' executable\n...\n</code></pre>"},{"location":"doc/bindings/","title":"YS Binding Libraries","text":"<p>Your existing YAML files are perfectly valid YS files! Using a YS binding library (aka module or package) these files can be loaded into native objects just like a YAML loader would do.</p> <p>Without a <code>!YS-v0</code> tag at the top they will load the same as normal. With that tag, they can be made to take advantage of any of the vast YS functional capabilities.</p> <p>YS intends to provide a YS capable YAML loader library (module/package) for every programming language that uses YAML. These libraries are meant to be full replacements for the existing YAML loaders in that language.</p> <p>Note</p> <p>YS loaders only return data values that adhere to the JSON data model. While that model is a subset of what can be represented in YAML 1.2, it is what most users of YAML expect. In other words, YS is targeted at YAML's most popular use cases.</p>"},{"location":"doc/bindings/#advantages-of-using-ys","title":"Advantages of using YS","text":"<p>YS YAML loaders have major advantages over the existing YAML loaders:</p> <ul> <li>Same API and capabilities regardless of the programming language.</li> <li>New features and bux fixes released to all languages at the same time.</li> <li>Highly configurable. Limit YAML and YS capabilities to your exact needs.</li> <li>Created by a YAML Specification\u00a0 creator &amp; maintainer.</li> </ul>"},{"location":"doc/bindings/#currently-available-libraries","title":"Currently Available Libraries","text":"<p>Currently there are working libraries for:</p> <ul> <li>Clojure\u00a0 </li> <li>Go\u00a0 </li> <li>Java\u00a0 </li> <li>Julia\u00a0 </li> <li>NodeJS\u00a0 </li> <li>Perl\u00a0 </li> <li>Python\u00a0 </li> <li>Raku\u00a0 </li> <li>Ruby\u00a0 </li> <li>Rust\u00a0 </li> </ul> <p>Install these libraries like you would any other library for your language. You must also install the matching version of the <code>libyamlscript.so</code> shared library. See Installing YS for more info.</p> <p>You can use these libraries like any other YAML loader. Here's an example usage in Python:</p> <p>File <code>program.py</code>:</p> <pre><code>from yamlscript import YAMLScript\nys = YAMLScript()\ninput = open('file.ys').read()\ndata = ys.load(input)\nprint(data)\n</code></pre> <p>File <code>file.ys</code>:</p> <pre><code>!YS-v0:\n\n::  # Set values to use in data\n  name =: \"World\"\n  other =: load(\"other.yaml\")\n\nfoo:: -[(6 * 7), inc(41), 43.--, (3 .. 9):sum]\nbar:: other.stuff:shuffle.take(3)\nbaz:: \"Hello, $name!\"\n</code></pre> <p>File <code>other.yaml</code>:</p> <pre><code>stuff:\n- ark\n- banana\n- cat\n- doll\n- electron\n- flan\n- golf ball\n</code></pre> <p>Run:</p> <pre><code>$ python prog.py\n{'foo': [42, 42, 42, 42], 'bar': ['cat', 'flan', 'doll'], 'baz': 'Hello, World!'}\n</code></pre>"},{"location":"doc/chain/","title":"YS Dot Chaining","text":"<p>One of the most powerful features of YS is the ability to chain function calls together. Functions are chained together using the <code>.</code> operator.</p> <p>Here are some examples:</p> <pre><code>x.5                 # -&gt; (nth x 5)\nx.abc               # -&gt; (get+ x 'abc)\nx.foo()             # -&gt; (foo x)\nx.foo(abc 123)      # -&gt; (foo x abc 123)\nx.foo(abc _ 123)    # -&gt; (foo abc x 123)\nx.foo(abc 123 _)    # -&gt; (foo abc 123 x)\nx.foo(_ _ _)        # -&gt; (foo x x x)\nx.?                 # -&gt; (truey? x)\nx.!                 # -&gt; (falsey? x)\nx.++                # -&gt; (inc x)\nx.--                # -&gt; (dec x)\nx.#                 # -&gt; (count x)\nx.#?                # -&gt; (not (empty? x))\nx.#!                # -&gt; (empty? x)\nx.#++               # -&gt; (inc (count x))\nx.#--               # -&gt; (dec (count x))\nx.@                 # -&gt; (deref x)\nx.&gt;                 # -&gt; (DBG x)\nx.abc.5.foo(22).#++ # -&gt; (inc (count (foo (nth (get+ x 'abc) 5) 22)))\nx.&gt;.abc.&gt;.foo()     # -&gt; (foo (DBG (get+ (DBG x) 'abc)))\n</code></pre> <p>The <code>get+</code> looks up a key in a map (like the <code>get</code> function in Clojure) but given <code>x.y</code> looks for the string key <code>\"y\"</code> or the keyword <code>:y</code> or the symbol <code>'y</code> in the map <code>x</code>.</p> <p>Instead of needing to write <code>(:k y)</code> or <code>(get x \"y\")</code> or <code>(get x 'y)</code> depending on the type of the key, you can just write <code>x.y</code>.</p> <p>When <code>.</code> is used to call a function, the value of the LHS is passed as the first argument to the function on the RHS. When this is not the desired behavior, you can use <code>_</code> to indicate the position that the value should be passed as.</p> <p>Some core functions like <code>take</code> and <code>drop</code> (when called used the <code>.</code> operator) will automatically put the collection argument as the second argument.</p>"},{"location":"doc/cheat/","title":"YS Cheat Sheet","text":""},{"location":"doc/cheat/#ys-fundamentals","title":"YS Fundamentals","text":"<ul> <li>Valid YS code is always valid YAML</li> <li>YS has 3 modes: code, data, and bare</li> <li>Code mode data is treated as code (can toggle to data mode)</li> <li>Data mode data is treated as data (can toggle to code mode)</li> <li>Bare mode data is treated as data (cannot toggle; always normal YAML)</li> <li>YS files must start with a YS (YAMLScript) tag:</li> <li><code>!YS-v0</code> - Start in code mode</li> <li><code>!YS-v0:</code> - Start in data mode</li> <li>No tag - Start in bare mode (plain YAML; no code evaluation)</li> <li>Initial tagged pair of <code>!YS v0:</code> is an alternative; starts in bare mode</li> <li>YS code mode always uses these YAML forms:</li> <li>Block mappings (normal indented mappings; <code>:</code> separated pairs)</li> <li>Plain scalars (no quotes)</li> <li>Quoted scalars (single or double or literal (<code>|</code>))</li> <li>Theses YAML forms are NOT allowed in code mode:</li> <li>Flow mappings and sequences (<code>{}</code> and <code>[]</code>)</li> <li>Block sequences (lines starting with <code>-</code>)</li> <li>Folded scalars (<code>&gt;</code>)</li> <li>All YAML forms are allowed in data mode</li> <li><code>!</code> tag toggles between code and data mode</li> <li><code>a:: b</code> is sugar for <code>a: ! b</code> in mapping pairs</li> <li>Use <code>=&gt;: x</code> to write <code>x</code> as a mapping pair in code mode</li> </ul> <p>The following examples are in code mode unless otherwise noted.</p>"},{"location":"doc/cheat/#assignment","title":"Assignment","text":"<p>The space before the <code>=</code> is required.</p> <pre><code>hello =: 'Oh hello'\na b c =: -[1 2 3]  # Destructuring assignment\n</code></pre>"},{"location":"doc/cheat/#ys-expression-escapes","title":"YS expression escapes","text":"<p>YS expressions need to be written as valid YAML scalars. When an expression starts with YAML syntax characters like <code>{</code>, <code>[</code>, <code>*</code>, <code>#</code> then its not a valid YAML scalar. Also expressions that have stuff after a quoted string (<code>''</code> <code>\"\"</code>) are not valid YAML.</p> <p>You can turn text into a valid YAML plain scalar by prefixing it with a dash (<code>-</code>) or a plus (<code>+</code>). The dash or plus is removed when YS reads the scalar.</p> <p>Note: the dash cannot have whitespace after it, but the plus can.</p> <pre><code>-[1 2 3]: .map(inc)  # =&gt; [2 3 4]\n=&gt;: +\n  'foo' + 'bar'      # =&gt; 'foobar'\n</code></pre>"},{"location":"doc/cheat/#printing-text","title":"Printing text","text":"<pre><code>say: 'hello'        # String\nsay: hello          # Variable\nsay: \"$hello!!!\"    # Interpolated string\nsay: |              # Multiline interpolated string\n  Hello, $name!\n  How are you?\nprint: 'I have no newline'\nwarn: 'Prints to stderr (with trailing newline)'\n</code></pre>"},{"location":"doc/cheat/#define-a-function","title":"Define a function","text":"<p>YS functions, like Clojure functions, require a specific argument arity, and can be defined to be multi-arity.</p> <pre><code>defn greet(name):\n  say: \"Hello, $name!\"\n\ndefn greet(name='world'):  # Default argument\n\ndefn foo(bar *baz): # Variable number of arguments\n\ndefn foo(*):        # Any number of arguments\n\ndefn foo(_ x _):    # Ignored arguments\n\ndefn foo:           # Multi-arity function\n  (): 0\n  (x): x\n  (x y): x + y\n</code></pre>"},{"location":"doc/cheat/#call-a-function","title":"Call a function","text":"<pre><code>greet()             # Scalar call variations\ngreet('Bob')\n(greet 'Bob')\n-'Bob'.greet()\n\ngreet:              # Map pair call variations\ngreet: 'Bob'\ngreet 'Bob':\n</code></pre>"},{"location":"doc/cheat/#chain-calls","title":"Chain calls","text":"<pre><code>say: read('/usr/share/dict/words')\n     .lines():shuffle.take(3).join(' | ')\n# =&gt; specialty | mutation's | Kisangani\n</code></pre> <p>Note</p> <p><code>.lines():shuffle</code> is short for <code>.lines().shuffle()</code>. It must be be attached to something on the left.</p>"},{"location":"doc/cheat/#special-chain-operators","title":"Special chain operators","text":"<ul> <li><code>.@</code> - Short for <code>.deref()</code></li> <li><code>.$</code> - Short for <code>.last()</code></li> <li><code>.#</code> - Short for <code>.count()</code></li> <li><code>.?</code> - Short for <code>.truey?()</code></li> <li><code>.!</code> - Short for <code>.falsey?()</code></li> <li><code>.??</code> - Short for <code>.boolean()</code></li> <li><code>.!!</code> - Short for <code>.not()</code></li> <li><code>.++</code> - Short for <code>.inc()</code></li> <li><code>.--</code> - Short for <code>.dec()</code></li> <li><code>.&gt;&gt;&gt;</code> - Short for <code>.DBG()</code></li> </ul>"},{"location":"doc/cheat/#looping","title":"Looping","text":"<p>List comprehensions are done with the <code>for</code>, <code>each</code>, <code>map</code> <pre><code>each i (1 .. 3):\n  say: i\n</code></pre></p> <pre><code>map inc: (1 .. 3)\n</code></pre> <pre><code>reduce (fn [acc num] acc + num) 0: (1 .. 3)\n</code></pre> <p>reduce _ 0 (1 2 3):   fn(acc num): acc + num The <code>_</code> is a placeholder for the defined function argument. Use <code>_</code> when the function argument is too long to write in place.</p>"},{"location":"doc/cheat/#conditional-ifelse","title":"Conditional (if/else)","text":"<pre><code>if a &gt; 10:\n  say: 'BIG'\n  say: 'small'\n</code></pre> <p>The <code>if</code> construct must have a 'then' and an 'else' clause. Use the `</p>"},{"location":"doc/cheat/#conditional-cond","title":"Conditional (cond)","text":"<pre><code>cond:\n  a &lt; 5: 'S'\n  a &lt; 10: 'M'\n  a &lt; 15: 'L'\n  =&gt;: 'XL'\n</code></pre>"},{"location":"doc/cheat/#interpolation","title":"Interpolation","text":"<pre><code>say: |\n  Dear $name,\n\n  I have 3 words for you: $(words().take(3 ).join(', ')).\n\n  Yours truly, $get(ENV 'USER')\n</code></pre>"},{"location":"doc/cheat/#global-variables","title":"Global variables","text":"<pre><code>- _                 # Previous document value\n- +++               # Runtime state mapping\n- ARGV              # Command line arguments\n- ARGS              # Command line arguments parsed\n- CWD               # Current working directory\n- DIR               # Parent directory path of the current script\n- ENV               # Environment variables mapping\n- FILE              # File path of the current script\n- INC               # File loading include path\n- RUN               # Runtime information mapping\n- VERSION           # YS version\n</code></pre>"},{"location":"doc/cli/","title":"Cli","text":"<p>one</p> <p><pre><code>foo: bar\n</code></pre> two</p>"},{"location":"doc/clj-to-ys/","title":"From Clojure to YS","text":"<p>YS (YAMLScript) works by translating code written in YS to Clojure code, which is then evaluated.</p> <p>A good way to learn YS is to convert existing Clojure programs to YS.</p> <p>This tutorial will guide you through the process of converting various Clojure programs to idiomatic YS a step at a time.</p> <p>For each Clojure program, we will:</p> <ul> <li>Start with a working Clojure program</li> <li>Refactor some parts of the program to YS</li> <li>Repeat until YS is idiomatic</li> <li>Have working YS code every step of the way</li> </ul> <p>If you don't know Clojure, that's okay. We're starting simple and you can learn 2 languages for the price of one.</p> <p>Let's get started!</p>"},{"location":"doc/clj-to-ys/#hello-world","title":"Hello World","text":"<p>Since we are obligated as programmers to start with a \"Hello, World!\" program, let's look at the simplest hello-world in Clojure:</p> <pre><code>(println \"Hello, World!\")\n</code></pre> <p>It turns out the this program is already valid YS!</p> <pre><code>$ ys -e '(println \"Hello, World!\")'\nHello, World!\n</code></pre> <p>Let's save it to a file called <code>program.ys</code> and run it.</p> <pre><code>(println \"Hello, World!\")\n</code></pre> <pre><code>$ ys program.ys\n$\n</code></pre> <p>Dang. Nothing happened.</p> <p>Let's compile it to Clojure to see what's going on.</p> <pre><code>$ ys -c program.ys\n\"(println \\\"Hello, World!\\\")\"\n</code></pre> <p>Ah! It compiled to a string, because we forgot to add <code>!YS-v0</code> to the top of the file. All YAML files are valid YS files. They won't evaluate any code unless you explicitly tell them to.</p> <pre><code>!YS-v0\n(println \"Hello, World!\")\n</code></pre> <pre><code>$ ys program.ys\nHello, World!\n</code></pre> <p>There we go!</p> <p>Let's make it idiomatic now.</p> <pre><code>!YS-v0\nsay: 'Hello, World!'\n</code></pre> <p>Look mom, no parentheses!</p> <p>We turned the YAML scalar into a single pair mapping, and we changed the double-quoted string to a single-quoted string.</p> <p>Single-quoted strings are preferred in YS unless you need interpolation or special escaped characters.</p> <p>We also changed the <code>println</code> function to the <code>say</code> function, because who has time to type <code>println</code> when you just want to <code>say</code> something?!?!</p> <p>Let's compile it back to Clojure to be honest with ourselves.</p> <pre><code>$ ys -c program.ys\n(say \"Hello, World!\")\n</code></pre> <p>We got our Clojure parentheses and double-quoted string back. Clojure doesn't use single quotes for strings.</p> <p>We still have <code>say</code> instead of <code>println</code>, but that's okay because <code>ys -c</code> compiles to Clojure code intended to be run by a YS runtime, and <code>say</code> is part of the YS standard library.</p>"},{"location":"doc/clj-to-ys/#hello-20","title":"Hello 2.0","text":"<p>Let's make our little program a little more interesting.</p> <pre><code>(defn hello\n  ([name] (println (str \"Hello, \" name \"!\")))\n  ([] (hello \"World\")))\n(hello)\n(hello \"YS\")\n</code></pre> <p>We've defined a function <code>hello</code> that takes an optional <code>name</code> argument. If <code>name</code> is not provided, it defaults to <code>\"World\"</code>.</p> <p>Let's convert this to YS, but change as little as possible.</p> <pre><code>!YS-v0\n=&gt;: !clj |\n  (defn hello\n    ([name] (println (str \"Hello, \" name \"!\")))\n    ([] (hello \"World\")))\n  (hello)\n  (hello \"YS\")\n</code></pre> <p>Hmm. We added 2 lines to the top and then indented the Clojure code. Does that work?</p> <pre><code>$ ys program.ys\nHello, World!\nHello, YS!\n</code></pre> <p>Apparently it does!</p> <p>We already know about the first line. The <code>=&gt;</code> is a special key in YS, when you need to write a YAML key/value pair, but you only have a value. The compiler simply removes the <code>=&gt;</code> and uses the value as the expression.</p> <p>What did here is keep the entire Clojure code string intact using a YAML literal scalar (think heredocs) and then use the <code>!clj</code> tag to tell the YS compiler to treat the string as Clojure code.</p> <p>The <code>!clj</code> tag is a way to write Clojure things that YS does not yet support. But it can also be a good first step to converting Clojure code to YS.</p> <p>Let's keep going by leaving the function defn alone but playing with the function calls.</p> <pre><code>!YS-v0\n=&gt;: !clj |\n  (defn hello\n    ([name] (println (str \"Hello, \" name \"!\")))\n    ([] (hello \"World\")))\nhello:\nhello: 'YS'\n</code></pre> <p>We made the 2 calls to <code>hello</code> into YAML mapping pairs. The first one has no value, and that's valid in YS when a function has no arguments.</p> <p>Now let's convert the function defn to YS.</p> <pre><code>!YS-v0\ndefn hello:\n (name): (println (str \"Hello, \" name \"!\"))\n (): (hello \"World\")\nhello:\nhello: 'YS'\n</code></pre> <p>That's how you write a multi-arity function in YS. It's advanced stuff and you already learned it during hello-world! Take a moment! You deserve it!</p> <pre><code>!YS-v0\ndefn hello(name='world'):\n  (println (str \"Hello, \" name \"!\"))\nhello:\nhello: 'YS'\n</code></pre> <p>Hey! What happened to our multi-arity accomplishment? We don't need it here in YS, because YS has support for default function arguments.</p> <p>Let's finish up with a little interpolation.</p> <pre><code>!YS-v0\ndefn hello(name='world'):\n  say: \"Hello, $name!\"\nhello:\nhello: 'YS'\n</code></pre> <p>That's some idiomatic YS if I've ever seen it!</p>"},{"location":"doc/clj-to-ys/#fizzbuzz","title":"FizzBuzz","text":"<p>Let's continue our journey of refactoring cliche coding conundrums with the classic FizzBuzz\u00a0 .</p> <p>Here's a working Clojure implementation I found at Rosetta Code\u00a0 .</p> <pre><code>(defn fizzbuzz [start finish]\n  (map (fn [n]\n         (cond\n           (zero? (mod n 15)) \"FizzBuzz\"\n           (zero? (mod n 3)) \"Fizz\"\n           (zero? (mod n 5)) \"Buzz\"\n           :else n))\n    (range start finish)))\n\n(doseq [x (fizzbuzz 1 101)]\n  (println x))\n</code></pre> <p>We'll skip the <code>!clj</code> step this time and start by making this a top level YAML mapping.</p> <pre><code>!YS-v0\n\ndefn fizzbuzz(start finish):\n  (map (fn [n]\n         (cond\n           (zero? (mod n 15)) \"FizzBuzz\"\n           (zero? (mod n 3)) \"Fizz\"\n           (zero? (mod n 5)) \"Buzz\"\n           :else n))\n    (range start finish))\n\ndoseq [x (fizzbuzz 1 101)]:\n  (println x)\n</code></pre> <p>It works! Trust me! Don't do that! Run it yourself! But it works! Trust me!</p> <p>All we did was turn the top level expressions into YAML mapping pairs, by removing the outer parentheses and adding a colon in the middle.</p> <p>We also changed the defn args to use parens instead of square brackets.</p> <p>Let's make more expressions into pairs now.</p> <pre><code>!YS-v0\n\ndefn fizzbuzz(start finish):\n  map:\n    fn(n):\n      cond:\n        (zero? (mod n 15)): \"FizzBuzz\"\n        (zero? (mod n 3)): \"Fizz\"\n        (zero? (mod n 5)): \"Buzz\"\n        else: n\n    range: start finish\n\ndoseq [x (fizzbuzz 1 101)]:\n  println: x\n</code></pre> <p>We also changed <code>:else</code> to <code>else</code> because YS likes it that way.</p> <p>Does it work? You betcha! Are we done? Heck no!</p> <pre><code>!YS-v0\n\ndefn fizzbuzz(start finish):\n  map _ (start .. finish):\n    fn(n):\n      cond:\n        (zero? (mod n 15)): 'FizzBuzz'\n        (zero? (mod n 3)): 'Fizz'\n        (zero? (mod n 5)): 'Buzz'\n        else: n\n\ndoseq [x (fizzbuzz 1 100)]:\n  println: x\n</code></pre> <p>Ok, hmm. We moved the range up to the top of the map call but put a <code>_</code> right before it. And it's not a range call anymore, it's some operator expression.</p> <p><code>..</code> is the <code>rng</code> operator in YS and the end is inclusive so we didn't need to say 101 when we meant 100.</p> <p>The <code>_</code> is a placeholder for the pair value to go. In Clojure, many functions take a function as the first argument. If we need to actually define a big function there it would be nicer if we could do it last. In these cases <code>_</code> is our friend.</p> <p>Double quotes to single. What's next?</p> <pre><code>!YS-v0\n\ndefn fizzbuzz(start finish):\n  map _ (start .. finish):\n    fn(n):\n      cond:\n        (mod n 15).!: 'FizzBuzz'\n        (mod n 3).!:  'Fizz'\n        (mod n 5).!:  'Buzz'\n        else:         n\n\ndoseq x (fizzbuzz 1 100):\n  say: x\n</code></pre> <p>We replaced the <code>zero?</code> calls with a <code>.!</code> (short for <code>.falsey?()</code>) call. We also removed the square brackets from the <code>doseq</code> call because YS is cool like that.</p> <p>Getting better...</p> <p>In YS, if you define a function called <code>main</code> it will be called automatically when the program is run.</p> <p>Let's try that.</p> <pre><code>!YS-v0\n\ndefn main(start=1 finish=100):\n  each x (start .. finish):\n    say:\n      fizzbuzz: x\n\ndefn- fizzbuzz(n):\n  cond:\n    (mod n 15).!: 'FizzBuzz'\n    (mod n 3).!:  'Fizz'\n    (mod n 5).!:  'Buzz'\n    else:         n\n</code></pre> <p>We moved the heavy lifting code into a private function called <code>fizzbuzz</code> and simply call it from the <code>main</code> function for every number in our range.</p> <p>We also made it so we can pass in the start and finish values as arguments:</p> <pre><code>$ ys program.ys 35 42\nBuzz\nFizz\n37\n38\nFizz\nBuzz\n41\nFizz\n</code></pre> <p>Pretty sweet!</p> <p>Let's tidy up this code a bit more, and come down from our fizzy buzz.</p> <pre><code>!YS-v0\n\ndefn main(start=1 finish=100):\n  each x (start .. finish): x.fizzbuzz().say()\n\ndefn- fizzbuzz(n):\n  cond:\n    (n % 15).!: 'FizzBuzz'\n    (n % 3).!:  'Fizz'\n    (n % 5).!:  'Buzz'\n    else:       n\n</code></pre> <p>We made the body of <code>main</code> into a single pair by chaining the <code>x</code>, <code>fizzbuzz()</code>, and <code>say()</code> together. I wouldn't say this is idiomatic YS, it's a little less readable imho, but sometimes we got to show off a little.</p> <p>This is probably how I'd write that part:</p> <pre><code>  each x (start .. finish):\n    say: fizzbuzz(x)\n</code></pre> <p>See how <code>fizzbuzz</code> comes before the paren, not inside it? We call that a YeS expression and it's definitely idiomatic!</p> <p>Finally we replaced the <code>mod</code> calls with the <code>%</code> operator. To be fair, <code>%</code> is the <code>rem</code> operator and <code>%%</code> is the <code>mod</code> operator in but with positive numbers they do the same thing.</p> <p>I'm fizzed out! Let's move on!</p>"},{"location":"doc/clj-to-ys/#to-be-continued","title":"To Be Continued...","text":"<p>We'll continue this journey soon. I promise.</p> <p>I have lots more Idiomatic YS to show you.</p> <p>Stay tuned!</p>"},{"location":"doc/clojure/","title":"Clojure Basics","text":"<p>YS as a technology has many goals. YS as a programming language is essentially a different syntax for Clojure. However, YS is certainly not an attempt to replace Clojure.</p> <p>In theory YS could have been written in any language. But in reality, Clojure was the best choice for many reasons including:</p> <ol> <li>Clojure is a Lisp and Lisps are \"code as data\". Since YS is YAML and YAML is    data, Clojure is a natural fit.</li> <li>GraalVM's native-image compiler and Clojure's SCI runtime make it possible to    to use YS without Java or the JVM.</li> <li>Clojure's core libraries are extensive, robust and well-documented.</li> </ol> <p>Since YS code always translates to Clojure code, it's important to have a good understanding of Clojure to write good YS code.</p> <p>Again, Clojure is a Lisp dialect. Lisps work entirely with parenthesized expressions containing a function followed by its arguments (S-Expressions).</p> <p>For example:</p> <pre><code>(+ 1 2 3)  ; `+` is a function that adds its arguments\n(str \"Hello \" name \"!\")  ; `str` is a function that concatenates its arguments\n(println (str \"The answer is \" (+ 2 3 7) \"!\"))  ; Multiple nested expressions\n</code></pre> <p>The basic clojure syntactic forms are:</p> <ul> <li>Lists - <code>(a b c)</code></li> <li>Vectors - <code>[a b c]</code></li> <li>Maps - <code>{a b, c d}</code></li> <li>Symbols - <code>a</code>, <code>b</code>, <code>c</code></li> <li>Quoted forms - <code>'(...)</code>, <code>'[...]</code>, <code>'{...}</code>, <code>'abc</code></li> <li>Strings - <code>\"abc\"</code></li> <li>Numbers - <code>123</code>, <code>3.14</code></li> <li>Characters - <code>\\a</code>, <code>\\b</code>, <code>\\c</code></li> <li>Keywords - <code>:a</code>, <code>:b</code>, <code>:c</code></li> <li>Anonymous functions - <code>#(+ %1 %2)</code></li> <li>Sets - <code>#{a b c}</code></li> <li>Regex - <code>#\"abc\"</code></li> <li>Comments - <code>;</code> to end of line</li> <li>Commented out forms - <code>#_(+ a b c)</code></li> </ul> <p>See Introduction to Clojure\u00a0  for more about Clojure.</p>"},{"location":"doc/control/","title":"Control Flow","text":"<p>YS (iow Clojure) is a functional programming language. That means that everything is a function. Running a program is just a calling a function that calls other functions.</p> <p>Even though YS tries hard to look like an imperative language, you must keep in mind that it's functional and get familiar with how the flow works.</p> <p>This document will cover:</p> <ul> <li>Starting a program</li> <li>Variable scope</li> <li>Grouping expressions</li> <li>Looping functions and recursion</li> <li>Conditional expressions</li> </ul> <p>Note</p> <p>Some of the things that are called \"functions\" in in this document are actually \"macros\" or \"special forms\" in Clojure. The distinction is not particularly important here, but worth mentioning.</p>"},{"location":"doc/control/#starting-a-program","title":"Starting a Program","text":"<p>A YS file generally is just a bunch of <code>defn</code> calls to define functions.</p> <p>Sometimes there will be assignment expressions at the top level. Top level variables are global and can be used anywhere in the program. They belong to the file's namespace which is <code>main</code> by default.</p> <p>If a program defines a function called <code>main</code>, it will be called when the program is run. Any command line arguments will be passed to the <code>main</code> function after being cast to numbers if they look like numbers.</p> <p><code>program.ys</code>:</p> <pre><code>!YS-v0\n\ndefn main(word='Hello!' times=3):\n  each i (1 .. times):\n    say: \"$i) $word\"\n</code></pre> <pre><code>$ ys program.ys\n1) Hello!\n2) Hello!\n3) Hello!\n</code></pre> <pre><code>$ ys program.ys YS 2\n1) YS\n2) YS\n</code></pre> <p>If a program does not define a <code>main</code> function, then nothing will happen unless you've defined a top level function call yourself. YS files that are meant to be used as libraries will not have a <code>main</code> function or a top level function call.</p>"},{"location":"doc/control/#variable-scope","title":"Variable Scope","text":"<p>One cool thing about YS (and Clojure) is that you can use any word as a variable name. Even things like <code>if</code> and <code>for</code> which are reserved words in many languages.</p> <p>For example you might do this:</p> <pre><code>defn foo(list):\n  count =: count(list)\n  if count &gt; 0:\n    say: 'The list is not empty'\n  else:\n    say: 'The list is empty'\n</code></pre> <p>Once we bind <code>count</code> to the result of the <code>count</code> function, we can't use the <code>count</code> function again in that scope. Often this is just fine. And it feels nice that you don't have to think up a synonym or alternative mangling for <code>count</code>.</p>"},{"location":"doc/control/#grouping-expressions","title":"Grouping Expressions","text":"<p>Some expression contexts allow multiple expressions to be grouped together and some only allow a single expression.</p> <p>You can group multiple expressions together with a <code>do</code> function call when you need to to do multiple things in a context that only allows a single expression.</p> <pre><code>if a &gt; b:\n  do:\n    say: 'a is greater than b'\n    say: 'a must be HUGE!'\n  say: 'Nothing to see here'\n</code></pre> <p>Note</p> <p>The <code>if</code> function actually supports the better named <code>then</code> and <code>else</code> words for grouping, but <code>do</code> can also be used.</p>"},{"location":"doc/control/#looping-functions-and-recursion","title":"Looping Functions and Recursion","text":"<p>YS has a few looping functions: <code>loop</code>, <code>reduce</code>, <code>for</code> and <code>each</code>.</p> <p>These will be documented in more detail in the future, but for now you can see the Clojure documentation for them:</p> <ul> <li>loop\u00a0 </li> <li>reduce\u00a0 </li> <li>for\u00a0 </li> <li><code>each</code> is a YS function that calls to a <code>for</code> expression inside a   <code>doall</code> expression.   This allows you to print things in the loop body.   In every other way it's the same as <code>for</code>.</li> </ul>"},{"location":"doc/control/#conditional-expressions","title":"Conditional Expressions","text":"<p>YS has a few common conditional expressions: <code>if</code>, <code>when</code>, <code>cond</code> and <code>case</code>.</p>"},{"location":"doc/control/#the-if-function","title":"The <code>if</code> Function","text":"<p>In YS, an <code>if</code> expression is a function that takes 3 arguments: a condition, a then expression and an else expression.</p> <pre><code>if a: b c  # If a is true, return b, else return c\n</code></pre> <p>The <code>b</code> and <code>c</code> expressions can also be mapping pairs:</p> <pre><code>if a:\n  say: 'yes'\n  say: 'no'\n</code></pre> <p>Sometimes you want to do more than one thing in the then or else expression:</p> <pre><code>if a:\n  then:\n    say: 'yes'\n    say: 'yes'\n  else:\n    say: 'no'\n    say: 'no'\n</code></pre> <p>If you use <code>then</code> you must also use <code>else</code>, but <code>else</code> can be used without a <code>then</code>:</p> <pre><code>if a:\n  say: 'yes'\n  else:\n    say: 'no'\n    say: 'no'\n</code></pre> <p>Since <code>if</code> is a function, it has a return value.</p> <pre><code>say:\n  if a: -'yes' 'no'\n</code></pre> <p>Any variable assigned in the <code>then</code> or <code>else</code> expression will only apply to that expression and not to the surrounding scope.</p> <pre><code>x =: 1\nif a &gt; b:\n  x =: 2\n  x =: 3\n=&gt;: x    # =&gt; 1\n</code></pre> <p>What you want to do here is capture the result of the <code>if</code> expression:</p> <pre><code>x =:\n  if a &gt; b:\n    then: 2\n    else: 3\n=&gt;: x    # =&gt; 2 or 3\n</code></pre> <p>Note that <code>say</code> returns <code>nil</code>, so all the <code>if</code> expressions above would also return <code>nil</code>.</p>"},{"location":"doc/control/#the-when-function","title":"The <code>when</code> Function","text":"<p>YS also has a <code>when</code> function that is like <code>if</code> but without an else expression.</p> <pre><code>when a:\n  say: 'yes'\n</code></pre> <p>The <code>if</code> function should only be used wen you have a then and an else expression. Otherwise, use <code>when</code>.</p> <p>One thing about <code>when</code> is that its body can have multiple expressions.</p> <pre><code>when a:\n  say: 'yes'\n  say: 'yes'\n</code></pre>"},{"location":"doc/control/#the-cond-function","title":"The <code>cond</code> Function","text":"<p>The <code>cond</code> function is like a series of <code>if</code> expressions but with multiple conditions.</p> <pre><code>size =:\n  cond:\n    a &lt; 20:  'small'\n    a &lt; 50:  'medium'\n    a &lt; 100: 'large'\n    else:    'huge'\n</code></pre>"},{"location":"doc/control/#the-case-function","title":"The <code>case</code> Function","text":"<p>The <code>case</code> function is like a <code>cond</code> but with a single expression to compare against.</p> <pre><code>count =:\n  case a:\n    1: 'one'\n    2: 'two'\n    3: 'three'\n    else: 'many'\n</code></pre>"},{"location":"doc/core/","title":"Clojure Core Essentials","text":"<p>YS has a very large set of useful functions that it inherits from Clojure's <code>clojure.core</code> library\u00a0 .</p> <p>These functions are the bread and butter building blocks of YS programming.</p> <p>The functions are very well organized in the Clojure Docs Quick Reference\u00a0  and you can get to the documentation for each function from there.</p> <p>This document is a condensed quick reference of the functions that are most commonly used in YS programming.</p> <p>YS also has the <code>ys::std</code> standard library that provides additional functions.</p> <p>The YS standard library replaces some Clojure functions with a version more suited to YS. In those cases, the original Clojure function is still available in the <code>ys::clj</code> namespace.</p>"},{"location":"doc/core/#number","title":"Number","text":""},{"location":"doc/core/#arithmetic","title":"Arithmetic","text":"<p>Clojure Core:</p> <ul> <li>+\u00a0 , -\u00a0 , *\u00a0 , /\u00a0 , inc\u00a0 , dec\u00a0 , max\u00a0 , min\u00a0 , rand\u00a0 , rand-int\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>%</code>, <code>%%</code> infix operators</li> <li><code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code> named math functions</li> <li><code>sum</code>, <code>sqr</code>, <code>cube</code>, <code>sqrt</code>, <code>pow</code>, <code>abs</code></li> <li><code>add+</code>, <code>sub+</code>, <code>mul+</code>, <code>div+</code> polymorphic functions</li> </ul> <p>See Also:</p> <ul> <li><code>clojure.math</code>    functions callable as <code>math/&lt;func-name&gt;</code> in YS.</li> </ul>"},{"location":"doc/core/#comparison","title":"Comparison","text":"<p>Clojure Core:</p> <ul> <li>&lt;\u00a0 , &gt;\u00a0 , &lt;=\u00a0 , &gt;=\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>==</code>, <code>!=</code> infix operators</li> <li><code>eq</code>, <code>ne</code>, <code>lt</code>, <code>gt</code>, <code>le</code>, <code>ge</code> named comparison functions</li> </ul>"},{"location":"doc/core/#cast","title":"Cast","text":"<p>Clojure Core:</p> <ul> <li>byte\u00a0 , short\u00a0 , int\u00a0 , long\u00a0 , float\u00a0 , double\u00a0 , num\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>to-num</code>, <code>to-int</code>, <code>to-float</code> - polymorphic cast functions</li> </ul>"},{"location":"doc/core/#test","title":"Test","text":"<p>Clojure Core:</p> <ul> <li>zero?\u00a0 , pos?\u00a0 , neg?\u00a0 , even?\u00a0 , odd?\u00a0 , number?\u00a0 </li> </ul>"},{"location":"doc/core/#boolean","title":"Boolean","text":"<p>Clojure Core:</p> <ul> <li>nil?\u00a0 , true?\u00a0 , false?\u00a0 , boolean\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>truey?</code>, <code>falsey?</code>, <code>to-bool</code>, <code>to-booly</code></li> </ul>"},{"location":"doc/core/#string","title":"String","text":"<p>Clojure Core:</p> <ul> <li>str\u00a0 , pr-str\u00a0 , prn-str\u00a0 , with-out-str\u00a0 , count\u00a0 , subs\u00a0 , format\u00a0 , string?\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>words</code>, <code>split</code>, <code>join</code>, <code>lines</code>, <code>text</code>, <code>replace</code>, <code>replace1</code></li> <li><code>chomp</code>, <code>trim</code>, <code>triml</code>, <code>trimr</code>, <code>lc</code>, <code>uc</code>, <code>uc1</code>, <code>index</code>, <code>pretty</code></li> </ul> <p>See Also:</p> <ul> <li><code>clojure.string</code>    functions callable as <code>str/&lt;func-name&gt;</code> in YS.</li> </ul>"},{"location":"doc/core/#regular-expression","title":"Regular Expression","text":"<p>Clojure Core:</p> <ul> <li>re-pattern\u00a0 , re-matches\u00a0 , re-find\u00a0 , re-seq\u00a0 , re-groups\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>=~</code>, <code>!~</code> infix operators</li> <li><code>/.../</code> regex literals</li> <li><code>qr</code></li> </ul>"},{"location":"doc/core/#flow-control","title":"Flow Control","text":""},{"location":"doc/core/#boolean_1","title":"Boolean","text":"<p>Clojure Core:</p> <ul> <li>not\u00a0 , and\u00a0 , or\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>||</code>, <code>&amp;&amp;</code>, <code>|||</code>, <code>&amp;&amp;&amp;</code> infix operators</li> <li><code>or?</code>, <code>and?</code> booly named functions</li> </ul>"},{"location":"doc/core/#normal","title":"Normal","text":"<p>Clojure Core:</p> <ul> <li>if\u00a0 , when\u00a0 , if-not\u00a0 , when-not\u00a0 , if-let\u00a0 , when-let\u00a0 , if-some\u00a0 , when-some\u00a0 , cond\u00a0 , condp\u00a0 , case\u00a0 , do\u00a0 , eval\u00a0 , loop\u00a0 , recur\u00a0 , while\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>if-lets</code>, <code>when-lets</code>, <code>call</code>, <code>each</code>, <code>exit</code>, <code>sleep</code></li> </ul>"},{"location":"doc/core/#exception","title":"Exception","text":"<p>Clojure Core:</p> <ul> <li>try\u00a0 , catch\u00a0 , finally\u00a0 , throw\u00a0 , assert\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>die</code>, <code>warn</code>, <code>exit</code>, <code>err</code></li> </ul>"},{"location":"doc/core/#function","title":"Function","text":"<p>Clojure Core:</p> <ul> <li>fn\u00a0 , defn\u00a0 , defn-\u00a0 , identity\u00a0 , comp\u00a0 , partial\u00a0 , complement\u00a0 , constantly\u00a0 , -&gt;\u00a0 , -&gt;&gt;\u00a0 , apply\u00a0 , fn?\u00a0 , ifn?\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>\\(...)</code> anonymous function syntax</li> <li><code>.</code> dot chaining infix operator</li> <li><code>value</code>, <code>call</code></li> </ul>"},{"location":"doc/core/#collection","title":"Collection","text":""},{"location":"doc/core/#general","title":"General","text":"<p>Clojure Core:</p> <ul> <li>count\u00a0 , empty\u00a0 , not-empty\u00a0 , into\u00a0 , conj\u00a0 , contains?\u00a0 , distinct?\u00a0 , empty?\u00a0 , every?\u00a0 , some\u00a0 , not-every?\u00a0 , not-any?\u00a0 , coll?\u00a0 , seq?\u00a0 , vector?\u00a0 , list?\u00a0 , map?\u00a0 , set?\u00a0 , sorted?\u00a0 , sequential?\u00a0 , associative?\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>grep</code>, <code>has?</code>, <code>in?</code></li> </ul>"},{"location":"doc/core/#vector","title":"Vector","text":"<p>Clojure Core:</p> <ul> <li>vec\u00a0 , vector\u00a0 , vec-of\u00a0 , conj\u00a0 , peek\u00a0 , pop\u00a0 , get\u00a0 </li> </ul>"},{"location":"doc/core/#list","title":"List","text":"<p>Clojure Core:</p> <ul> <li>list\u00a0 , cons\u00a0 , conj\u00a0 , peek\u00a0 , pop\u00a0 , first\u00a0 , rest\u00a0 </li> </ul>"},{"location":"doc/core/#map","title":"Map","text":"<p>Clojure Core:</p> <ul> <li>hash-map\u00a0 , array-map\u00a0 , sorted-map\u00a0 , zipmap\u00a0 , frequencies\u00a0 , assoc\u00a0 , assoc-in\u00a0 , dissoc\u00a0 , find\u00a0 , get-in\u00a0 , update-in\u00a0 , key\u00a0 , val\u00a0 , keys\u00a0 , vals\u00a0 , merge\u00a0 , reduce-kv\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>omap</code>, <code>get+</code></li> </ul>"},{"location":"doc/core/#sequence","title":"Sequence","text":"<p>Clojure Core:</p> <ul> <li>seq\u00a0 , repeat\u00a0 , range\u00a0 , iterate\u00a0 , cycle\u00a0 , interleave\u00a0 , interpose\u00a0 , first\u00a0 , second\u00a0 , last\u00a0 , rest\u00a0 , next\u00a0 , butlast\u00a0 , nth\u00a0 , take\u00a0 , drop\u00a0 , take-while\u00a0 , drop-while\u00a0 , conj\u00a0 , concat\u00a0 , map\u00a0 , filter\u00a0 , remove\u00a0 , sort\u00a0 , shuffle\u00a0 , flatten\u00a0 , for\u00a0 , doseq\u00a0 , dorun\u00a0 , doall\u00a0 , mapcat\u00a0 , reduce\u00a0 , keep\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>..</code> infix rng operator</li> <li><code>rng</code>, <code>reverse</code></li> </ul>"},{"location":"doc/core/#variable","title":"Variable","text":"<p>Clojure Core:</p> <ul> <li>def\u00a0 , intern\u00a0 , declare\u00a0 , binding\u00a0 , gensym\u00a0 , var\u00a0 , var-get\u00a0 , resolve\u00a0 , find-var\u00a0 , alter-var-root\u00a0 , var?\u00a0 , bound?\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>=:</code>, <code>.=:</code>, <code>+=:</code>, <code>-=:</code>, <code>*=:</code>, <code>/=:</code> def/let syntax</li> <li><code>value</code></li> </ul>"},{"location":"doc/core/#io","title":"I/O","text":"<p>Clojure Core:</p> <ul> <li>print\u00a0 , printf\u00a0 , println\u00a0 , pr\u00a0 , prn\u00a0 , print-str\u00a0 , println-str\u00a0 , pr-str\u00a0 , prn-str\u00a0 , newline\u00a0 , flush\u00a0 , read\u00a0 , write\u00a0 , with-out-str\u00a0 , with-open\u00a0 , with-in-str\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>say</code>, <code>out</code>, <code>warn</code>, <code>pp</code></li> </ul>"},{"location":"doc/define/","title":"Defining Variables and Functions","text":"<p>Two of the most common things you'll want to do in YS code is to define variables and functions.</p> <p>It's very simple. Here's an example:</p> <pre><code>!YS-v0\n\nname =: 'world'\n\ndefn main():\n  greeting =: 'Hello'\n  say: \"$greeting, $name!\"\n</code></pre> <p>To define a variable with a value we specify a symbol name, followed by one or more spaces, followed by <code>=:</code> for the YS key (the LHS). The variable will be set to the result of the evaluation of the mapping pair's value (the RHS).</p> <p>To define a function we use <code>defn</code>, followed by the function name followed by the parenthesized arguments for the LHS. The RHS is the function body.</p> <p>Let's see how this compiles to Clojure internally using <code>ys -c file.ys</code>:</p> <pre><code>(def name \"world\")\n(defn main [] (let [greeting \"Hello\"] (say (str greeting \", \" name \"!\"))))\n(apply main ARGS)\n</code></pre> <p>In our YS code we defined 2 variables: <code>name</code> and <code>greeting</code>. But in the Clojure code one became a <code>def</code> expression and the other used <code>let</code>. Using <code>=:</code> outside a function uses <code>def</code> and it's a file scope variable. Using <code>=:</code> inside a function uses <code>let</code> and the scope is the remainder of the function.</p> <p>This is idiomatic Clojure.</p>"},{"location":"doc/env-vars/","title":"YS Environment Vars","text":"<p>YS has a number of environment variables that can be set to control its behavior. These variables each begin with <code>YS_</code> and are all uppercase with underscores separating words.</p> <ul> <li> <p><code>YSPATH</code> - A colon-separated list of directories to search for YS library   files loaded with the <code>use</code> function.   This is the only YS environment variable that doesn't start with <code>YS_</code>, but   there is an equivalent <code>YS_PATH</code> that can be used instead.</p> </li> <li> <p><code>YS_PATH</code> - An alternative to <code>YSPATH</code> that is used if <code>YSPATH</code> is not set.</p> </li> <li> <p><code>YS_PRINT=1</code> - Same as <code>-p</code> (<code>--print</code>) command line option.</p> </li> <li> <p><code>YS_STREAM=1</code> - Same as <code>-s</code> (<code>--stream</code>) command line option.</p> </li> <li> <p><code>YS_OUTPUT=&lt;file-name&gt;</code> - Same as <code>-o</code> (<code>--output=&lt;file-name&gt;</code>) command line   option.</p> </li> <li> <p><code>YS_FORMAT=&lt;yaml|json|edn|csv|tsv&gt;</code> - Same as <code>-t</code> ()</p> </li> <li> <p><code>YS_UNORDERED=1</code> - Same as <code>-u</code> (<code>--unordered</code>) command line option.</p> </li> <li> <p><code>YS_XTRACE=1</code> - Same as <code>-x</code> (<code>--xtrace</code>) command line option.</p> </li> <li> <p><code>YS_STACK_TRACE=1</code> - Same as <code>-S</code> (<code>--stack-trace</code>) command line option.</p> </li> <li> <p><code>YS_SHOW_OPTS=1</code> - Print all the option values.</p> </li> <li> <p><code>YS_SHOW_LEX=1</code> - Print the lexed tokens of each YS expression.</p> </li> <li> <p><code>YS_SHOW_INPUT=1</code> - Print the input YS expressions.</p> </li> </ul>"},{"location":"doc/examples/","title":"YS by Example","text":"<p>One of the best ways to learn a new programming language is to see examples of real code written in that language. This page contains a links to programs written in YS.</p> <p>Note</p> <p>The YS documentation is a work in progress. Looking at real life examples is a solid way to get started. If you feel the urge to contribute to the documentation, please do so. It would be greatly appreciated!</p>"},{"location":"doc/examples/#ys-examples-of-refactoring-large-yaml-files","title":"YS Examples of Refactoring Large YAML Files","text":"<ul> <li>Calva's CircleCI Config\u00a0 </li> <li>HelmYS Helm Templating\u00a0 </li> </ul>"},{"location":"doc/examples/#ys-examples-of-programs-utilities-and-automation","title":"YS Examples of Programs, Utilities and Automation","text":"<ul> <li>Rosetta Code\u00a0    YS (YAMLScript) solutions to Rosetta Code tasks.</li> <li>yamllm\u00a0    A command line multi LLM (Anthropic, OpenAI, Gemma) query tool.</li> <li>sbs\u00a0    Creates markdown gists to compare pairs of files \"side by side\".   Used to show differences between YS and Go templates in Helm.</li> <li>Example gist comparing Helm templates in YS and Go\u00a0 </li> <li>ys-vs-rc\u00a0    Compares YS and Rosetta Code solutions to the same problem in many languages.</li> <li>Example gist comparing FizzBuzz in YS vs many other languages\u00a0 </li> <li>YS Repository Utilities</li> <li>util/release-yamlscript\u00a0      The utility that orchestrates the release of YS, including 12 binary builds     and <code>libyamlscript.so</code> bindings for 10 programming languages.</li> <li>util/brew-update\u00a0      The utility that updates the Homebrew formula for YS.</li> <li>util/mdys\u00a0      Renders Markdown with embedded YS code blocks.     Used for the YS documentation.</li> <li>util/version-bump\u00a0      Bumps the version of dozens of YS files in the repository at     release time.</li> </ul> <p>More examples will be added here as they become known.</p> <p>If you have YS example code you'd like to share, please submit a PR to the YS Repo\u00a0 .</p>"},{"location":"doc/exercism/","title":"Learn YS at Exercism","text":"<p>Exercism\u00a0  is a platform that offers code practice and mentorship for everyone. It is a great way to improve your coding skills and learn new programming languages.</p> <p>Exercism provides a series of exercises in over 70 programming languages\u00a0  including YS / YAMLScript\u00a0  , and you can get feedback from mentors on your solutions.</p> <p>It is a fun and interactive way to learn to code, and it is completely free to use. If you are looking to improve your coding skills or learn a new language, Exercism is a good place to start.</p>"},{"location":"doc/gotchas/","title":"Common YAML / YS Gotchas","text":"<p>All YS files are required to be valid YAML. YS uses most of YAML's capabilities and flexibilities to create a clean programming language (one that doesn't look like just a bunch of data).</p> <p>Unfortunately, this means that you can run into some situations where your YS code looks perfectly fine but is actually invalid YAML.</p> <p>Here's a common gotcha. YS can repeat a string with this syntax: <code>'foo' * 3</code> yields <code>'foofoofoo'</code>.</p> <p>However, the following is not valid and would cause a YAML parsing error:</p> <pre><code>say: 'foo' * 3\n</code></pre> <p>This is because YAML sees a single quoted scalar and text content is not allowed to follow the closing quote.</p> <p>YS provides the <code>+</code> escaping character to fix this:</p> <pre><code>say: +'foo' * 3\n# (these also work in this case):\nsay: ('foo' * 3)\nsay: 3 * 'foo'\n</code></pre> <p>Now the right-hand side is a plain scalar wThis is because YAML sees a single quoted scalar and text content is not allowed to follow the closing quote.hose value is <code>+'foo' * 3</code>. YS will ignore the leading <code>+</code> and evaluate the expression as expected.</p> <p>This <code>+</code> escaping character can be used anywhere that you need to use a plain scalar to write a YS expression but the leading character would otherwise be interpreted as YAML syntax.</p> <p>Another example:</p> <pre><code># Here [3 4 5] is a YS vector, not a YAML sequence.\n# Again we make the entire RHS a plain scalar by starting with a `+`.\nsay: +[3 4 5].reverse()\n</code></pre> <p>It is super common to use <code>[]</code> vectors and <code>{}</code> mappings in Clojure code expressions and thus in YS code expressions. In YAML, the same syntax is used for flow sequence and mapping nodes. This can cause confusion.</p> <p>We \"fix\" this, again, by using the <code>+</code> escaping character. Also, we simply disallow (in code mode) YAML flow sequences and flow mappings. Using the <code>+</code> to get the scalar expression version of the same thing works fine (and as a bonus, there is no need for the commas and colons).</p> <p>For example: <pre><code>!YS-v0\n\n# This is an error (using a flow sequence in code mode):\nsay: [1, 2, 3]\n# This is a scalar that re-parses as a vector:\nsay: +[1, 2, 3]\n# And thus does not need the commas (commas are whitespace in previous line):\nsay: +[1 2 3]\n# We can use the YAML flow collection syntax if we switch to data mode:\nsay:: [1, 2, 3]\n# Same switching as above, but with `!` instead of `::`:\nsay: ! [1, 2, 3]\n# The commas are require in YAML flow collection syntax.\n</code></pre></p> <p>YAML block sequences (lines starting with <code>-</code>) are also disallowed in code mode.</p> <p>The rationale here is that if you ever see <code>{</code>, <code>[</code>, <code>-</code> or <code>&gt;</code> (folded scalar) you can assume that you are in data mode and not code mode.</p> <p>Example errors:</p> <pre><code>$ ys -e 'say: [1, 2, 3]'\nError: Sequences (block and flow) not allowed in code mode\n\n$ ys -e '\nsay:\n- 1\n- 2\n- 3'\nError: Sequences (block and flow) not allowed in code mode\n</code></pre> <p>There are various ways to do it correctly:</p> <pre><code>$ ys -e 'say:: [1, 2, 3]'\n[1 2 3]\n\n$ ys -e '\nsay::\n- 1\n- 2\n- 3'\n[1 2 3]\n\n$ ys -e 'say: +[1, 2, 3]'\n[1 2 3]\n</code></pre> <p>Don't worry, you'll get the hang of it quickly!</p>"},{"location":"doc/install/","title":"Installing YS","text":"<p>YS has 3 main things you might want to install:</p> <ol> <li>The <code>ys</code> compiler, loader and runner command.</li> <li>The <code>libyamlscript.so</code> shared library needed by a YS loader library for your    particular programming language.</li> <li>A YS loader library for your    particular programming language, like Python, Rust, NodeJS, etc.</li> </ol>"},{"location":"doc/install/#quick-install-of-ys-and-libyamlscript","title":"Quick Install of <code>ys</code> and <code>libyamlscript</code>","text":"<p>You can install both <code>ys</code> and <code>libyamlscript</code> with a single CLI command, where:</p> <ul> <li><code>VERSION</code> defaults to the latest YS version.</li> <li><code>PREFIX</code> defaults to <code>$HOME/.local</code>.</li> <li><code>LIB=1</code> means only install the shared library.</li> <li><code>BIN=1</code> means only install the <code>ys</code> binary.</li> </ul> <p>Examples: <pre><code>$ curl https://yamlscript.org/install | bash\n$ curl https://yamlscript.org/install | VERSION=0.1.95 bash\n$ curl https://yamlscript.org/install | VERSION=0.1.95 LIB=1 bash\n$ curl https://yamlscript.org/install | PREFIX=/tmp/yamlscript bash\n</code></pre></p> <p>For the <code>ys</code> command you'll need to have <code>PREFIX/bin</code> in your <code>PATH</code>, but the install script will tell you that.</p> <p>For <code>libyamlscript</code>, unless you use the default <code>PREFIX</code> you'll need to add <code>PREFIX/lib</code> to <code>LD_LIBRARY_PATH</code> and export that variable.</p> <p>An even shorter command to install <code>ys</code></p> <pre><code>$ curl -s https://getys.org/ys | bash\n</code></pre> <p>You can use all the same options as above (before <code>bash</code>).</p>"},{"location":"doc/install/#download-and-install","title":"Download and Install","text":"<p>All the binary pre-built release files are here\u00a0 .</p> <ul> <li>Download the appropriate release file.</li> <li>Expand the file with <code>$ tar xf &lt;release-file&gt;</code>.</li> <li>Use <code>cd</code> to enter the release directory.</li> <li>Run <code>make install</code> or <code>make install PREFIX=...</code>.</li> <li>Or just copy the binary file to the place where you want it.</li> </ul>"},{"location":"doc/install/#build-a-release-from-source","title":"Build a Release from Source","text":"<p>You can also easily build and install <code>ys</code> and <code>libyamlscript</code> from source:</p> <ul> <li>Download the \"Source code\" release file.</li> <li>Expand the file with <code>$ tar xf &lt;release-file&gt;</code>.</li> <li>Use <code>cd</code> to enter the release directory.</li> <li>Run <code>make install</code> or <code>make install PREFIX=...</code>.</li> </ul> <p>This will take a few minutes but it requires no dependencies besides <code>bash</code>, <code>make</code> and <code>curl</code>.</p> <p>Note</p> <p>On Linux it also requires the <code>libz-dev</code> package.</p>"},{"location":"doc/install/#install-a-ys-loader-library","title":"Install a YS Loader Library","text":"<p>YS loader libraries are intended to be a  drop in replacement for your current YAML loader.</p> <p>YS loader libraries are currently available for these programming languages:</p> <ul> <li>Clojure\u00a0 </li> <li>Go\u00a0 </li> <li>Java\u00a0 </li> <li>Julia\u00a0 </li> <li>NodeJS\u00a0 </li> <li>Perl\u00a0 </li> <li>Python\u00a0 </li> <li>Raku\u00a0 </li> <li>Ruby\u00a0 </li> <li>Rust\u00a0 </li> </ul> <p>Install the library you want using the normal library installer for your language. Then install the matching version of the <code>libyamlscript</code> shared library as described above.</p> <p>Note</p> <p>Currently when you install a YS loader library for your particular programming language you must also install the <code>libyamlscript</code> shared library of the exact same version. Fortunately this is simple.</p>"},{"location":"doc/intro/","title":"Introducing YS","text":"<p>YS is a new approach to providing the extra capabilities that YAML users have been asking for (or adding themselves) for years. YS embeds cleanly into existing YAML files and adds new capabilities such as:</p> <ul> <li>Getting data from other YAML files</li> <li>Assigning variables</li> <li>Referencing other parts of YAML (without anchorsi/aliases)</li> <li>Interpolating variables and function calls into strings</li> <li>Transforming data structures</li> <li>Defining and calling functions</li> <li>Using external libraries</li> <li>Running shell commands</li> <li>And much more...</li> </ul> <p>All of YS is (and must be) valid YAML syntax, even though it might seem surprising from time to time. Also all YAML config files are valid YS files and YS will treat them as such (no code execution), unless you explicitly tell it to do more (by adding a <code>!YS-v0</code> tag to the start).</p> <pre><code>!YS-v0\nsay: \"Welcome to YS!\"\n</code></pre> <p>YS is also a complete, mature, functional, performant programming language. That's because under the hood, YS code is compiled to Clojure\u00a0  code and evaluated by a Clojure runtime. For most day to day YS use, you won't need to know anything about Clojure, but when you need to do something more advanced, all of Clojure\u00a0  is available for you to use.</p> <p>Even though Clojure is a Lisp, YS code looks a lot more like Python, Ruby, Perl or JavaScript. And even though Clojure is a JVM (Java) language, YS doesn't use the JVM at all. YS is a fast standalone native binary, as is the <code>libyamlscript</code> shared library that it is used by all YS loader libraries.</p>"},{"location":"doc/loaders/","title":"YS Loader Libraries","text":"<p>YS is focused on providing a loader library for every programming language where YAML is used. Ideally it should be a drop-in replacement for the existing YAML loader library you are using.</p> <p>All existing YAML config files are already valid YS files and using the YS loader to load them should work without any changes. The advantage of using the YS loader is that they all work the same way and provide the same capabilities, regardless of the underlying programming language.</p> <p>The following loader libraries are currently available:</p> <ul> <li>Clojure\u00a0 </li> <li>Go\u00a0 </li> <li>Java\u00a0 </li> <li>Julia\u00a0 </li> <li>NodeJS\u00a0 </li> <li>Perl\u00a0 </li> <li>Python\u00a0 </li> <li>Raku\u00a0 </li> <li>Ruby\u00a0 </li> <li>Rust\u00a0 </li> </ul>"},{"location":"doc/mode-tags/","title":"YS Mode Tags","text":"<p>YS has 3 modes that every node in a YAML document can be in: data, code, and bare.</p> <p>By default YS sees YAML files as being in bare mode, and loads them according to basic YAML rules.</p> <p>You need to use a special tag for YS to be able to use logic in a YAML file.</p> <p>These tags are applied to each document (top level node) in a YAML file. Since most YAML files only have one document, you can think of these tags as being declared at the top of the files and being applied to the whole file.</p>"},{"location":"doc/mode-tags/#v0-ys-mode-tags","title":"v0 YS Mode Tags","text":"<ul> <li><code>!YS-v0</code> - Start in code mode.</li> <li><code>!YS-v0:</code> - Start in data mode.</li> <li><code>!code</code> - Start in code mode. Must come after a <code>!YS-v0</code> tag.</li> <li><code>!data</code> - Start in data mode. Must come after a <code>!YS-v0</code> tag.</li> <li><code>!bare</code> - Start in bare mode. Must come after a <code>!YS-v0</code> tag.</li> </ul> <p>The <code>!code</code>, <code>!data</code>, and <code>!bare</code> tags are used for clarity but can only be used on a document that follows a document with a <code>!YS-v0</code> tag.</p> <p>One way to use <code>!data</code> without have a previous document is:</p> <pre><code>!YS-v0\n--- !data\nnum:: 6 * 7  # 42\n</code></pre> <p>In reality this YAML has two documents, but since the first one has no content it is ignored by the YS compiler. Even though it is ignored, it serves to add the <code>!YS-v0</code> tag to the file, so that you can now use <code>!data</code> or <code>!code</code> or <code>!bare</code> tags in the rest of the file.</p> <p>Note</p> <p>Every document in a YAML file is considered \"bare\" unless it has a mode tag at the top of that document.</p>"},{"location":"doc/mode-tags/#alternate-v0-ys-mode-tags","title":"Alternate v0 YS Mode Tags","text":"<p>Originally, these mode tags were supported for YS v0:</p> <ul> <li><code>!yamlscript/v0</code> - Start in code mode.</li> <li><code>!yamlscript/v0:</code> - Start in data mode.</li> <li><code>!yamlscript/v0/code</code> - Start in code mode.</li> <li><code>!yamlscript/v0/data</code> - Start in data mode.</li> <li><code>!yamlscript/v0/bare</code> - Start in bare mode.</li> </ul> <p>These tags are still supported for backwards compatibility, but the <code>!YS-v0</code> tags are preferred. They may be removed in a future version of YS.</p>"},{"location":"doc/modes/","title":"YS Syntax Modes","text":"<p>One of the most important things to understand when learning YS is the concept of \"modes\".</p> <p>It basically comes down to whether an unquoted scalar like <code>count</code> should be considered as a data string or a code symbol (variable, function name etc). Since the main focus of YS is about embedding code into YAML data files, it's very important to know what mode you are in at any given point.</p> <p>YS has 3 modes:</p> <ul> <li>Bare mode</li> </ul> <p>Exactly the same as YAML 1.2 (Core Schema).   YS can load most existing files without executing any code.</p> <ul> <li>Data mode</li> </ul> <p>Very similar to bare mode, but allows you to switch to code mode.   All YAML syntax forms are allowed here.</p> <ul> <li>Code mode</li> </ul> <p>Plain (unquoted) scalars are treated as code expressions.   YAML's flow mappings (<code>{}</code>), flow sequences (<code>[]</code>) and block sequences (<code>-</code>)   are not allowed in code mode.   YS \"code\" is  written using block mappings (<code>k: v</code>), plain scalars,   quoted scalars (single and double) and literal (<code>|</code>) scalars.   Folded scalars (<code>&gt;</code>) are also disallowed in code mode.</p> <p>The most important ones to learn about are data and code modes. To use YS effectively you'll need to be comfortable with switching back and forth between the two.</p> <p>Bare mode is the default when you haven't added a <code>!YS-v0</code> tag to the start of a YS document. It means that everything in the file is data; code can never be used. This is how we can make sure that existing YAML files are valid YS.</p> <p>To enable a YAML file to use YS code, you need to add one of these tags to the top:</p> <ul> <li><code>!YS-v0</code> - Start in code mode.</li> <li><code>!YS-v0:</code> - Start in data mode.</li> <li><code>!YS v0:</code> - Tagged key/val pair that starts in bare mode.</li> </ul> <p>Consider the following examples.</p> <p>Bare mode:</p> <pre><code>$ ys --load &lt;(echo '\nfoo:\n  count: [red, green, blue]')\n{\"foo\":{\"count\":[\"red\",\"green\",\"blue\"]}}\n</code></pre> <p>Data mode:</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0:\nfoo:\n  count: [red, green, blue]')\n{\"foo\":{\"count\":[\"red\",\"green\",\"blue\"]}}\n</code></pre> <p>Code mode:</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0\nfoo:\n  count: [red, green, blue]')\nError: Sequences (block and flow) not allowed in code mode\n</code></pre> <p>Oops. Looks like we need to switch to data mode in there.</p>"},{"location":"doc/modes/#switching-modes","title":"Switching Modes","text":"<p>If we want to add a function to a data file we should start in data mode. Then we should switch to code mode for things that are code.</p> <p>Here we want to call the <code>count</code> function with a sequence and get back 3, the number of elements in the sequence.</p> <p>The special tag <code>!</code> can be used to switch from data to code and vice versa.</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0:\nfoo: !\n  count: [red, green, blue]')\nError: Sequences (block and flow) not allowed in code mode\n</code></pre> <p>Here we started in data mode but then switched the mode to code with <code>!</code>. We got the same error. YS only allows block mappings for code. We need to put <code>[red, green, blue]</code> into data mode:</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0:\nfoo: !\n  count: ! [red, green, blue]')\n{\"foo\":3}\n</code></pre> <p>It worked!</p> <p>Using <code>!</code> is so common that YS has a cleaner way to do it when used on a mapping pair value. If you use <code>::</code> instead of <code>:</code> it does the same thing.</p> <p>Let's try it out:</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0:\nfoo::\n  count:: [red, green, blue]')\n{\"foo\":3}\n</code></pre> <p>Sweet!</p> <p>However, when switching in a sequence you'll need to use <code>!</code>:</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0:\n- !\n  count:: [red, green, blue]')\n[3]\n</code></pre> <p>NOTE: <code>::</code> isn't special YAML syntax. YS cannot change YAML 1.2 syntax in any way. In the examples above <code>count:</code> is simply a plain scalar ending with <code>:</code>.</p> <p>We can see that in bare mode:</p> <pre><code>$ ys --load &lt;(echo '\ncount:: [red, green, blue]')\n{\"count:\":[\"red\",\"green\",\"blue\"]}\n</code></pre>"},{"location":"doc/operators/","title":"YS Operators","text":"<p>YS has a number of operators that you can use in your code.</p> <p>Review YeS Expressions to see how YS supports infix operator expressions, whereas Clojure requires the operator to precede the operands.</p> <p>When YS operators are used with infix notation, they often become polymorphic and do things according to the types of the operands.</p> <pre><code>!YS-v0\ns =: ('foo' + 'bar')  # =&gt; 'foobar'\ns =: (+ 'foo' 'bar')  # ERROR - Clojure + only works on numbers\n</code></pre> <p>You can see why by looking at the <code>ys -c</code> output:</p> <pre><code>$ ys -c -e \"s =: ('foo' + 'bar')\" -e \"s =: (+ 'foo' 'bar')\"\n(def s (add+ \"foo\" \"bar\"))\n(def s (+ \"foo\" \"bar\"))\n</code></pre> <p>See how the infix <code>+</code> operator compiles to the <code>add+</code> function? The <code>add+</code> function works on numbers, strings, characters, sequences, mappings, sets and functions!</p> <p>Note</p> <p>If you absolutely need the Clojure <code>+</code> function for performance reasons, you can simply use the prefix form: <code>(+ a b)</code>.</p>"},{"location":"doc/operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li><code>+</code> - Addition - Infix works on strings, sequences, and mappings or else casts   arguments to numbers.</li> <li><code>-</code> - Subtraction - Works on numbers.</li> <li><code>*</code> - Multiplication - Infix works on numbers or <code>str * num</code>, <code>num * str</code>,   <code>seq * num</code>, <code>num * seq</code>.</li> <li><code>/</code> - Division - Works on numbers. Infix returns a double in the cases where   Clojure would return a ratio.</li> <li><code>%</code> - Remainder - Works on numbers. Compiles to <code>rem</code> in Clojure.</li> <li><code>%%</code> - Modulus - Works on numbers. Compiles to <code>mod</code> in Clojure.</li> <li><code>**</code> - Exponentiation - Works on numbers and has right associativity.</li> </ul>"},{"location":"doc/operators/#comparison-operators","title":"Comparison Operators","text":"<ul> <li><code>==</code> - Equal To - Works on any comparable values.</li> <li><code>!=</code> - Not Equal To - Works on any comparable values.</li> <li><code>&gt;</code> - Greater Than - Works on numbers. Supports <code>a &gt; b &gt; c</code>.</li> <li><code>&gt;=</code> - Greater Than or Equal To - Works on numbers.</li> <li><code>&lt;</code> - Less Than - Works on numbers.</li> <li><code>&lt;=</code> - Less Than or Equal To - Works on numbers.</li> </ul> <p>These operators have the respective named functions: <code>eq</code>, <code>ne</code>, <code>gt</code>, <code>ge</code>, <code>lt</code>, <code>le</code> for use in places where a function makes more sense than an operator.</p>"},{"location":"doc/operators/#conditional-operators","title":"Conditional Operators","text":"<p>In Clojure <code>false</code> and <code>nil</code> are treated as \"false\" and everything else is treated as \"true\".</p> <p>YS adds the concept of \"truey\" and \"falsey\" values. Empty strings, empty collections, <code>0</code>, <code>false</code>, and <code>nil</code> are \"falsey\" and everything else is \"truey\".</p> <p>This concept applies to some operators.</p> <ul> <li><code>&amp;&amp;</code> - Logical And</li> <li><code>||</code> - Logical Or</li> <li><code>&amp;&amp;&amp;</code> - Truey And</li> <li><code>|||</code> - Truey Or</li> </ul>"},{"location":"doc/operators/#regular-expression-operators","title":"Regular Expression Operators","text":"<ul> <li><code>=~</code> - <code>a =~ b</code> calls <code>re-find(b a)</code>. Coerces <code>a</code> to a string.</li> <li><code>!~</code> - <code>not(a =~ b)</code></li> <li><code>=~~</code> - <code>a =~ b</code> calls <code>re-matches(b a)</code>. Coerces <code>a</code> to a string.</li> <li><code>!~~</code> - <code>not(a =~~ b)</code></li> </ul>"},{"location":"doc/operators/#other-operators","title":"Other Operators","text":"<ul> <li> <p><code>.</code> - Function Chaining Operator</p> <p><code>a.b.3.c(d).e(f)</code> compiles to: <code>(e (c (nth (get+ a 'b) 3) d) f)</code>.</p> </li> <li> <p><code>..</code> - Range Operator</p> <p><code>1 .. 3</code> -&gt; <code>(1 2 3)</code>, <code>3 .. 1</code> -&gt; <code>(3 2 1)</code>.</p> <p>Differs from Clojure's <code>range</code>  function.</p> </li> </ul>"},{"location":"doc/query/","title":"Convert/Query/Transform","text":"<p>You can use the <code>ys</code> command line tool to convert, query and transform YAML (or JSON since JSON is YAML) files much like you would with <code>jq</code>  or <code>yq</code> .</p> Install <code>ys</code> Now! <pre><code>curl -s https://getys.org/ys | bash\n</code></pre> <p>YS is an excellent tool for these types of CLI 1-liner tasks, because it:</p> <ul> <li>Is a full programming language with 100s of builtin functions</li> <li>Has a great compact \"dot notation\" syntax</li> <li>Has many options for output formats and other niceties</li> </ul> <p>For example, to get the first 5 keys of a subsection of a YAML file that start with a vowel and print the result as YAML to stdout:</p> <pre><code>$ ys '.some.0.part:keys.filter(/^[aeiou]/).take(5)' file.yaml\n- id\n- enabled\n- owner\n- interval\n- environment\n</code></pre> Should I use <code>yq</code> or <code>ys</code>? <p>Both!</p> <p>While <code>yq</code> currently has features that <code>ys</code> does not (like updating files in place and preserving comments), <code>ys</code> has a much larger set of functions (it's an entire programming language) to make use of.</p> <p>Both are fantastic tools and can be used together for great good!</p>"},{"location":"doc/query/#ys-conversion-examples","title":"YS Conversion Examples","text":"<p>Click on the examples below to see more details.</p> <ul> <li> <p>Convert YAML/JSON to other formats</p> <code>ys -J file.yaml\u00a0\u00a0\u00a0# Convert to JSON</code> <p>Use one of these Load options: * <code>-l</code>/<code>--load</code> Load input and print as compact JSON * <code>-J</code>/<code>--json</code> Print as formatted JSON * <code>-Y</code>/<code>--yaml</code> Print as YAML * <code>--csv</code> Print as CSV * <code>--tsv</code> Print as TSV * <code>--edn</code> Print as EDN</p> <p>Prints the data in the specified format to stdout.</p> <p>Examples: <pre><code>ys -l file.yaml  # --load for compact JSON output\n</code></pre> <pre><code>ys -J file.yaml  # Pretty JSON output\n</code></pre> <pre><code>ys -l file.yaml | jq .   # Pipe to jq for even prettier JSON output\n</code></pre> <pre><code>&lt; file.yaml ys -l -  # Read from stdin (use - for file name)\n</code></pre> <pre><code>&lt; file.yaml ys -l    # -l with no file argument reads from stdin\n</code></pre></p> </li> <li> <p>Show code evaluation in a format</p> <code>ys -Ye ENV\u00a0\u00a0\u00a0# Environment as YAML</code> <p><pre><code>ys -Ye ENV  # Environment as YAML\n</code></pre> <pre><code>ys -Ye 'ENV:sort:flat:O'  # Sorted\n</code></pre></p> </li> </ul>"},{"location":"doc/query/#many-more-examples-soon","title":"Many more examples soon...","text":""},{"location":"doc/referencing/","title":"Referencing YAML Nodes","text":"<p>One thing that's important when adding code to YAML is having ways for the code to reference other data.</p>"},{"location":"doc/run-ys/","title":"Self Installation Scripts","text":"<p>Note</p> <p>If you just ran a program with <code>bash</code> that printed a URL to this page, click the arrow below for more information on \"What just happened?\" below.</p> What just happened? <p>If you are reading this you probably just ran a YS program with <code>bash</code>. The first time you do that, the program installed the <code>ys</code> interpreter under the <code>/tmp/</code> directory for you and then ran the program with it. Subsequent runs of the program will use that installed <code>ys</code> interpreter.</p> <p>You may continue to run the program this way, but there will be a slight delay at the start each time while the <code>run-ys</code> auto-installer script is downloaded.</p> <p>It is very easy to install the <code>ys</code> interpreter permanently on your system so that you can run the program with <code>ys</code> instead of <code>bash</code>.</p> <pre><code>$ curl -s https://yamlscript.org/install-ys | bash\n</code></pre> <p>See the YS Installation page for more information.</p> <p>YS has a way to publish programs that people can run immediately without having installed the <code>ys</code> interpreter first.</p> <p>Warning</p> <p>See the Security Considerations below before using this technique.</p> <p>Just begin your YS program with these lines:</p> <pre><code>#!/usr/bin/env ys-0\nsource &lt;(curl '-s' 'https://yamlscript.org/run-ys') \"$@\" :\n</code></pre> <p>Then anyone can run your program using Bash with a command like this: <code>bash script.ys arg1 arg2 ...</code>.</p> <p>The first time they do so, the <code>ys</code> interpreter will be downloaded and installed under the <code>/tmp/</code> directory.</p> <p>The <code>ys</code> interpreter will be downloaded only once, and it will be used for all subsequent runs of the script.</p> <p>Note</p> <p>The <code>curl</code> command will still download and evaluate the <code>run-ys</code> Bash script on subsequent runs so the user will need to have internet access.</p> <p>The program can also be run with the <code>ys</code> interpreter if the user installs it. In that case the Bash installer line will be ignored.</p> <p>Since the program has a shebang line, it can also be run as a <code>PATH</code> command if the file is marked as executable.</p>"},{"location":"doc/run-ys/#example","title":"Example","text":"<p>Here's a small YS program that program that prints the ROT13 encoding of its arguments:</p> <pre><code>#!/usr/bin/env ys-0\n\nsource &lt;(curl '-s' 'https://yamlscript.org/run-ys') \"$@\" :\n\nalphabet =: set((\\\\A .. \\\\Z) + (\\\\a .. \\\\z))\nrot13 =: cycle(alphabet).drop(13 * 2).zipmap(alphabet)\n\ndefn main(*input):\n  say: str/escape(input.join(' ') rot13)\n</code></pre> <p>If we run it with <code>ys</code>:</p> <pre><code>$ ys rot13.ys I Love YS\nV Ybir LF\n</code></pre> <p>If we run it with <code>bash</code>:</p> <pre><code>$ bash rot13.ys I Love YS\nInstalling the YS CLI '/tmp/yamlscript-run-ys/bin/ys-0.1.95' now...\nCtl-C to abort\nSee https://yamlscript.org/doc/run-ys for more information.\n\nInstalled /tmp/yamlscript-run-ys/bin/ys - version 0.1.95\n--------------------------------------------------------------------------------\nV Ybir LF\n</code></pre> <p>and again:</p> <pre><code>$ bash rot13.ys I Love YS\nV Ybir LF\n</code></pre>"},{"location":"doc/run-ys/#how-it-works","title":"How It Works","text":"<p>The program is both valid YS and valid Bash.</p> <p>YS programs are required to start with a YAML tag like this:</p> <pre><code>!YS-v0\n</code></pre> <p>But if they start with a shebang line like this:</p> <pre><code>#!/usr/bin/env ys-0\n</code></pre> <p>then the <code>!YS-v0</code> tag is optional.</p> <p>When you run the program with <code>bash</code>, the shebang line is merely a comment and ignored by Bash.</p> <p>The <code>source</code> line is a Bash command that reads and evaluates the contents of the <code>&lt;(...)</code> process substitution file. The <code>curl</code> command inside downloads the <code>run-ys</code> script and installs the <code>ys</code> interpreter under the <code>/tmp/</code> directory if it is not already installed.</p> <p>It then <code>exec</code>s the installed <code>ys</code> interpreter with your original program and any arguments you provided.</p> <p>The <code>source</code> line is also a valid YS command. It calls the YS <code>source</code> macro which ignores all of its arguments (much like the <code>comment</code> macro does).</p>"},{"location":"doc/run-ys/#use-cases-and-security-considerations","title":"Use Cases and Security Considerations","text":"<p>This technique is may be useful in situations where you want to share a YS program with people who are not yet familiar with YS.</p> <p>Since the program is run with Bash which gets more Bash code from the internet, it is subject to the many security risks of running arbitrary code from the internet.</p> <p>Caveat yamlscriptor!</p> <pre><code>A more secure way to distribute a YS program is to\n[compile it to a binary executable](binary.md) and distribute the binary\ninstead.\n</code></pre> <p>There is at least one use case where this Bash technique is safe and useful:</p> <p>You can easily run a YS program that you are developing with a particular version of the <code>ys</code> interpreter without having to install it first. Just use the <code>YS_VERSION</code> environment variable to specify the version you want:</p> <pre><code>$ YS_VERSION=0.1.95 bash my-program.ys arg1 arg2 ...\n</code></pre> <p>This might be useful for testing a reported bug with an older version of the interpreter, for example.</p> <p>There may be other development and testing use cases for this technique as well. If you find one, please let us know!</p>"},{"location":"doc/syntax/","title":"YS Syntax","text":"<p>The <code>ys</code> YS interpreter command runs YS programs by compiling them to Clojure code and evaluating that Clojure code.</p> <p>To fully understand YS you need to know:</p> <ul> <li>How YAML works</li> <li>How Clojure works</li> </ul> <p>This document will show you the basics of YS syntax and how they translate to Clojure code.</p> <p>Note</p> <p>You can play with all the concepts here by putting example code into a file like <code>example.ys</code> and running <code>ys -c example.ys</code> which will print the Clojure code that the YS code compiles to.</p>"},{"location":"doc/syntax/#first-steps","title":"First Steps","text":"<pre><code>!YS-v0\n(say \"Hello, world!\")\n</code></pre> <p>This is a simple YS program that prints \"Hello, world!\".</p> <p>An interesting point about YS is that is always valid YAML, and the YS compiler (<code>ys -c</code>) is really just a fancy YAML loader. Almost all YAML files are valid YS and the compiler turns them into the expected data structure.</p> <p>This is where the <code>!YS-v0</code> tag comes in. It tells the YS compiler to \"load\" the YAML into a YS AST which prints naturally to Clojure code.</p> <p>The point is that every YS program needs to start with the <code>!YS-v0</code> tag, or else it just compiles to a regular data structure.</p> <p>The second line is a YS function call that happens to be a Clojure function call.</p> <p>Let's play around with that function call syntax a bit.</p> <pre><code>!YS-v0\nsay(\"Hello, world!\")\n</code></pre> <p>This compiles to the same Clojure code as the first example. We moved the <code>say</code> function name outside the parentheses. In YS this is called a YeS Expression.</p> <p>Note that from a YAML perspective, the entire YAML document is a single scalar value.</p> <p>YS code uses YAML scalars and YAML block mappings for code. Generally a mix of the two where the top (file level) structure is a nested mapping and the leaf values are scalar expressions.</p> <p>Let's change our code to use a mapping instead:</p> <pre><code>!YS-v0\nsay: \"Hello, world!\"\n</code></pre> <p>Again, this compiles to the same Clojure code as the first two examples.</p> <pre><code>!YS-v0\nsay: 'Hello, world!'\n</code></pre> <p>This is the same as the previous example, but the string is single-quoted. Single quotes aren't used for strings in Clojure, but they are in YAML.</p> <p>In YS, like Perl and Ruby, double quoted strings support variable interpolation and character escaping while single quoted strings do not.</p> <p>Let's get a bit fancier with our string:</p> <pre><code>!YS-v0\nname =: 'world'\nsay: \"Hello, $name!\"\n</code></pre> <p>That's a variable assignment and a string interpolation.</p> <pre><code>!YS-v0\nname =: 'world'\nsay: str('Hello, ', name, '!')\n</code></pre> <p>Clojure as a <code>str</code> function that concatenates strings together.</p> <p>See the commas between the <code>str</code> call arguments? In Clojure, commas are whitespace and are completely ignored. This is also true in YS!</p> <p>In general Clojure and YS only use commas in places where the code is hard to follow without them.</p> <pre><code>!YS-v0\nname =: 'world'\nsay: -'Hello, ' + name + '!'\n</code></pre> <p>Here we are doing something that you don't see in Clojure. We're using <code>+</code> to concatenate strings.</p> <p>When YS operators are infix they compile to polymorphic functions that work on types of data other than numbers.</p> <p>But what about the <code>-</code> in front of the string?</p> <p>Without the <code>-</code> this would be invalid YAML because YAML does not allow text on the same line after a quoted string.</p> <p>The <code>-</code> causes YAML to see everything after it as the scalar value: <code>-'Hello, ' + name + '!'</code>. This is like an escape character for situations where you want to write an expression but the first character is a syntax character in YAML. The <code>-</code> is removed and the rest of the scalar is compiled as an expression.</p>"},{"location":"doc/syntax/#basic-function-definition","title":"Basic Function Definition","text":"<pre><code>defn greet(name):\n  say: \"Hello, $name!\"\n\ngreet: 'Bob'\n</code></pre> <p>In Clojure we'd write this as:</p> <pre><code>(defn greet [name]\n  (say \"Hello, \" name \"!\"))\n\n(greet \"Bob\")\n</code></pre> <p>It's pretty easy to see what's going on here.</p> <p>Note how we use indentation nesting where Clojure uses parentheses. That's just the natural way to do things in YAML. Most of the YS syntax design is about making code look natural in YAML. It works out surprisingly well!</p>"},{"location":"doc/syntax/#variable-assignment-def-and-let","title":"Variable Assignment (def and let)","text":"<p>In the remaining examples we'll assume the <code>!YS-v0</code> tag is present.</p> <p>Note</p> <p>What we are calling variable assignment is known as symbol binding in Clojure. Clojure differentiates between symbols and variables but the distinction is not so important for YS.</p> <p>Assignments are done by using <code>name =: expression</code>.</p> <pre><code>foo =: bar() + 17\n</code></pre> <p>It looks like <code>=:</code> is some syntax added to YAML, but it's actually just a plain scalar value that ends with a space and an equals sign!</p> <p>These would work just as well:</p> <pre><code>foo   =   :\n  bar()\n  + 17\n\n? foo\n  =\n: bar()\n  + 17\n</code></pre> <p>Note</p> <p>The second form above uses YAML's rarely seen explicit key syntax. It can be useful sometimes in YS when you need spread the key portion of a key/value mapping pair over multiple lines. Without it mapping keys are required by YAML to be a single line. The 'value' side can always be multiline and can start on the next line too. This is a very common pattern in YS to make code more readable.</p> <p>Assignment statements written at the file level compile to <code>def</code> forms in Clojure, while those written inside a function compile to <code>let</code> forms.</p> <pre><code>defn f1():\n  a =: this()\n  b =: that()\n  =&gt;: a + b\n</code></pre> <p>This compiles to:</p> <pre><code>(defn f1 []\n  (let [a (this)\n        b (that)]\n    (+ a b)))\n</code></pre> <p>Notice how multiple consecutive assignments are compiled to a single <code>let</code> form. This is the preferred Clojure style and YS tries to compile to idiomatic Clojure code whenever possible.</p> <p>What's with the <code>=&gt;</code>? The special token <code>=&gt;</code> can be used as a placeholder key for when you want to use a single expression but being inside a mapping requires you use a key/value pair. The <code>=&gt;</code> is removed during compilation and the expression is left as the value.</p>"},{"location":"doc/syntax/#destructuring-assignment","title":"Destructuring Assignment","text":"<p>Many modern languages have destructuring assignment, where the LHS of an assignment looks like a data structure instead of a single variable. This quasi-data-structure is a collection of variables that are assigned values from the RHS of the assignment.</p> <p>Clojure and YS have destructuring assignment support for both sequences and mappings.</p> <pre><code>-[a b c] =: foo()\n-{d :d e :e} =: bar()\n</code></pre> <p>This would assign the first three values of the sequence returned by <code>foo</code> to <code>a</code>, <code>b</code>, and <code>c</code>, and the values of the <code>:d</code> and <code>:e</code> keys of the mapping to <code>d</code> and <code>e</code>.</p> <p>This can also be done in function arguments:</p> <pre><code>defn f(a [b c] d):\n  =&gt;: (a + (b * c)) / d\nf: 2 [3 4] 7  # =&gt; 2\n</code></pre> <p>Here you would call <code>f</code> with a single sequence argument and the first three values of that sequence would be assigned to <code>a</code>, <code>b</code>, and <code>c</code> respectively.</p> <p>For some reason Clojure does not support destructuring assignment in <code>def</code> forms but YS makes it work just fine.</p>"},{"location":"doc/syntax/#function-arguments","title":"Function Arguments","text":"<p>Like Clojure, all YS functions must be defined with the number of arguments they take. This is know as the function's arity. Functions can be written to take different specific numbers of arguments, where each arity has its own definition body. Functions can also be written to take a variable number of arguments.</p> <p>Multi-arity functions are called with the same name but the number of arguments used determines which body is evaluated.</p> <p>Note that unlike some other languages with multi-arity functions, the type of the arguments is not used to determine which body to evaluate.</p> <p>For example to define a function that takes two or more arguments:</p> <pre><code>defn foo(a b *more): ...\n</code></pre> <p>To define a function that can take 0, 1 or 3+ arguments:</p> <pre><code>defn foo:\n  (): ...\n  (a): ...\n  (a b c *more): ...\n</code></pre> <p>It would be an error to call the above function with 2 arguments.</p>"},{"location":"doc/syntax/#default-values","title":"Default Values","text":"<p>Clojure does not support default values for function arguments but YS does.</p> <pre><code>defn foo(a b=10 c='horse'): ...\n</code></pre>"},{"location":"doc/syntax/#work-in-progress","title":"Work in Progress","text":"<p>This document is a work in progress. More content will be added soon.</p>"},{"location":"doc/syntax/#see-also","title":"See Also","text":"<ul> <li>YS Modes - Understanding code mode vs data mode</li> <li>YeS Expressions</li> </ul>"},{"location":"doc/tutorial/","title":"YS Syntax Basics","text":"<p>Let's start learning about YS syntax by looking at a simple YS program.</p> <p>Here's a program to print some numbers (10 of them by default) from the fibonacci sequence:</p> <pre><code>!YS-v0\n\ndefn main(n=10):\n  loop a 0, b 1, i 1:\n    say: a\n    when i &lt; n:\n      recur: b, (a + b), i.++\n</code></pre> <p>When you run a YS program using the <code>ys</code> interpreter command it:</p> <ul> <li>Compiles the YS code to Clojure code</li> <li>Evaluates the Clojure code</li> </ul> <p>Let's try it (requesting 8 numbers from the fibonacci sequence):</p> <pre><code>$ ys fib.ys 8\n0\n1\n1\n2\n3\n5\n8\n13\n</code></pre> <p>Great, but to understand it better let's look at the Clojure code that it compiled to:</p> <pre><code>$ ys -c fib.ys\n(defn main\n ([n]\n  (loop [a 0 b 1 i 1]\n   (say a)\n   (when (&lt; i n) (recur b (add+ a b) (inc i)))))\n ([] (main 10)))\n(apply main ARGS)\n</code></pre> <p>note:</p> <pre><code>When learning or debugging YS programs, it's often very helpful to look at\nthe generated Clojure code using `ys -c`.\n</code></pre> <p>We can see 2 top-level forms in the generated Clojure code. The first is the <code>main</code> function definition, and the second is the call to the <code>main</code> function with the command-line arguments. That's interesting, we didn't actually call <code>main</code> in our ys program.</p> <p>The YS compiler automatically adds a call to <code>main</code> if it detects the <code>main</code> was defined but not called in the program.</p> <p>The Clojure <code>main</code> function has 2 bodies, one with an argument <code>n</code> and the other without any arguments. In the YS program there is only one function body, but not that the <code>n</code> argument has a default value of <code>10</code>. Clojure doesn't support default arguments, but the YS compiler can generate a second body that takes no arguments and calls the first body with the default.</p>"},{"location":"doc/v0/","title":"Understanding \"v0\"","text":"<p>The domain of YAML in the world of programming is vast and varied.</p> <p>YS intends to continually grow to meet YAML's needs as new use cases arise.</p> <p>By now you should be aware of the \"v0\" syntax that is required in various places in YS.</p> <p>The \"v0\" is meant to declare the YS API version being used. At some point soon, v0 will be declared stable and a new version of the language will begin development. At that point, no breaking changes will be made to the v0 syntax, thus all v0 YS / YAML files will continue to work indefinitely.</p> <p>Any new version of YS is free to break compatibility with the previous versions, while still allowing previous versions of libraries and files to be used.</p>"},{"location":"doc/v0/#the-v0v1-story","title":"The v0/v1 Story","text":"<p>You might expect that the next new version after v0 would be v1, but YS v0 is robust enough to be named v1 and also declared stable at the same time. This eliminates the notion that a stable v0 isn't production ready.</p> <p>The truth is that v0 is already a very capable language and very few things should change before v0/v1 is declared stable.</p>"},{"location":"doc/v0/#roadmap-to-v1-stable","title":"Roadmap to v1 Stable","text":"<p>Here's a list of the things that we want to add or change before the v1 release:</p> <ul> <li>Change the loader bindings (Python, Rust, etc) <code>load()</code> function to not allow   code evaluation by default.</li> </ul> <p>We want full capabilities configuration support, but this is the minimum   required to be able to declare v0/v1 stable.</p> <ul> <li>A basic configuration system for YS files.</li> </ul> <p>This will allow for the configuration of the YS loader and other things.</p> <ul> <li>Use of external dependencies in YS files.</li> </ul> <p>We want v0 to be able to declare its dependency libraries from GitHub, Maven,   local files and other sources.</p> <ul> <li>Internal restructuring of the built-in libraries.</li> </ul> <p>We want to review the internal library names and function names and signatures   to make sure they are consistent and easy to use.   A few functions might be renamed, changed or removed.</p> <ul> <li>Add support for <code>v1</code> to be interpreted as <code>v0</code> in all cases.</li> </ul> <p>This is rather minor, but obviously needs to happen before v1 is declared a   stable equivalent to v0.</p> <p>We'll add to this list as necesary blockers are identified.</p> <p>Overall v0 is quite stable and we want to make the v0/v1 stable release as soon as possible.</p>"},{"location":"doc/v0/#places-where-v0-is-required","title":"Places where \"v0\" is required","text":"<ul> <li>YS mode tags \u2014 <code>!YS-v0</code>, <code>!yamlscript/v0</code>, etc.</li> <li>The <code>#!/usr/bin/env ys-0</code> shebang line. Here we use <code>ys-0</code> rather than <code>ys-v0</code>   because <code>ys-0</code> is the actual name of binary found in <code>PATH</code>.</li> </ul>"},{"location":"doc/vocab/","title":"YS Vocabulary","text":"<p>YAML and YS have specific names for the various parts of the language. It is important to understand these terms to be able to better understand the documentation and how the language works.</p>"},{"location":"doc/vocab/#yaml-vocabulary","title":"YAML Vocabulary","text":"<ul> <li> <p>file</p> <p>A YAML file is a text file that contains a YAML stream. The file name often has a <code>.yaml</code>, <code>.yml</code>, or <code>.ys</code> extension, but this is not required.</p> </li> <li> <p>stream</p> <p>A YAML stream is a sequence of zero or more documents. Each document is a complete YAML text. The documents are separated by <code>---</code> or <code>...</code> lines. The stream is the top-level structure of a YAML file.</p> </li> <li> <p>document</p> <p>A YAML document is a single YAML text. A document represents a single node; either a mapping, sequence or scalar.</p> </li> <li> <p>node</p> <p>A YAML node is a single piece of data. A node can be a mapping, sequence, or scalar.</p> </li> <li> <p>kind</p> <p>A generic word for mapping, sequence or scalar. You would say \"there are 3 kinds of nodes\", not \"there are 3 types of nodes\".</p> </li> <li> <p>mapping</p> <p>A YAML mapping is a collection of key/value pairs. The key and the value can be any node.</p> </li> <li> <p>sequence</p> <p>A YAML sequence is a sequential list of nodes. The nodes are ordered and can be any node.</p> </li> <li> <p>collection</p> <p>A YAML collection is either a mapping or a sequence.</p> </li> <li> <p>scalar</p> <p>A YAML scalar is a single piece of data. A scalar typically represents a string, number, boolean, or null, but it can be any object that can be represented in YAML serialized to a string form.</p> </li> <li> <p>pair</p> <p>A YAML pair is two consecutive nodes in a mapping. The first node is the key and the second node is the value.</p> </li> <li> <p>key</p> <p>The first node of a mapping pair.</p> </li> <li> <p>explicit key</p> <p>In a block mapping pair, a key can use a leading <code>?</code> as an explicit key indicator. This is useful if you need a scalar key to be multi-line:</p> <p><pre><code>? a long\n  key string\n: value\n</code></pre> same as:</p> <pre><code>a long key string: value\n</code></pre> <p>Note how the <code>:</code> is placed at the start of the line before the value. This is necessary when using the explicit key syntax.</p> </li> <li> <p>value</p> <p>The second node of a mapping pair.</p> </li> <li> <p>tag</p> <p>A YAML tag is an short string annotation attached to a =node that specifies how that node should be processed. Tags start with <code>!</code> followed by 0-n characters (excluding whitespace and certain syntax characters).</p> <p>Explicit tags are not often used in practice, but internally a YAML loader implicitly assigns a tag to every node that doesn't have an explicit tag.</p> </li> <li> <p>anchor</p> <p>A YAML anchor is a short string annotation attached to a =node that can be used to reference (=alias) that node elsewhere in the =document. Anchors start with <code>&amp;</code> followed by 1-n characters (excluding whitespace and certain syntax characters).</p> </li> <li> <p>property</p> <p>A term used to mean either the tag or the anchor of a node.</p> </li> <li> <p>alias</p> <p>A YAML alias is a short string annotation attached to a =node that references another =node with the same anchor.</p> </li> <li> <p>block style</p> <p>YAML collections can be written in either block style or flow style. Block style uses indentation to indicate structure. This is the most common style used in YAML files. Any sub-node of a block collection can use either block or flow style.</p> </li> <li> <p>flow style</p> <p>YAML collections can be written in either block style or flow style. Flow style uses curly braces, square brackets, colons and commas to indicate structure. Flow style is very much like JSON and is actually a superset of JSON. Sub-nodes of a flow collection must also use flow style.</p> </li> <li> <p>plain style scalar</p> <p>A YAML scalar can be written in any or 5 styles within a block collection: plain, single-quoted, double-quoted, literal, or folded. In a flow collection, only the plain, single-quoted, and double-quoted styles are allowed.</p> <p>A plain style scalar is one without any quoting. It can span multiple lines. It can't:</p> <ul> <li>Start or end with whitespace</li> <li>Start a YAML syntax character: <code>[]{},\"'&amp;*#?!|&gt;-%@</code></li> <li>Contain the <code>:</code> or <code>#</code> character sequences</li> <li>Make use of YAML escape sequences</li> </ul> </li> <li> <p>single-quoted style scalar</p> <p>A single-quoted style scalar is one enclosed in single quotes. It can span multiple lines. It uses the <code>''</code> sequence to represent a single quote within the scalar.</p> </li> <li> <p>double-quoted style scalar</p> <p>A double-quoted style scalar is one enclosed in double quotes. It can span multiple lines. It can make use of <code>\\</code> escape sequences to represent special characters.</p> </li> <li> <p>literal style scalar</p> <p>A literal style scalar is one that uses the <code>|</code> character to indicate that the scalar spans multiple lines. The scalar is written on the next line and all subsequent lines that are indented more than the first line are part of the scalar.</p> <p>Literal scalars are very much like here-documents seen in Perl and shell languages. You can use them to represent almost any text, including code files and other YAML files, simply by indenting them correctly.</p> <p>Even Makefiles, which have lines that start with tabs (which are forbidden in YAML indentation), can be represented in YAML literal scalars without changing the content.</p> </li> <li> <p>folded style scalar</p> <p>A folded style scalar is one that uses the <code>&gt;</code> character to indicate that the scalar spans multiple lines. Folded scalars follow certain rules that \"fold\" newlines and whitespace into single spaces. The rules are complicated. You can often get the desired results by just using plain style scalars instead.</p> </li> <li> <p>loader</p> <p>A YAML loader is a program that reads a YAML stream and converts it into a native data structure that can be used by the program. A loader is a stack of stages (aka transforms) that each convert their input from one state to another. The names of the transforms are: parser, composer, resolver and constructor.</p> </li> <li> <p>parser</p> <p>People often user the term \"parser\" to refer to the entire loader, but the parser is actually just one of the transforms in the loader. In most implmentations, the parser and the lexer are combined into a single transform that turns the input stream of characters into a stream of events.</p> <p>It is by far the most complex transform in the loader, and is defined by 211 productions in the YAML 1.2 specification.</p> </li> <li> <p>event</p> <p>An event is a data structure that represents a scalar value, an alias reference, or the start or end of a stream, document, mapping, or sequence. There are 10 types of events typically generated by the parser: STREAM-START, STREAM-END, DOCUMENT-START, DOCUMENT-END, MAPPING-START, MAPPING-END, SEQUENCE-START, SEQUENCE-END, SCALAR, and ALIAS.</p> <p>The event structures contain certain attributes of the input that are needed for further processing. For instance START-* and SCALAR events contain the style, tag, and anchor properties, and SCALAR events also contain the value. All events contain the start and end positions of the input that they represent.</p> </li> <li> <p>composer</p> <p>The loader stage that transforms the stream of events into a tree of nodes.</p> </li> <li> <p>resolver</p> <p>The loader stage that assigns tags to the nodes that didn't have an explicit one. Possibly normalizes the nodes in some way.</p> </li> <li> <p>constructor</p> <p>The loader stage that converts the nodes into a native data structure that can be used by the program.</p> </li> <li> <p>dumper</p> <p>A YAML dumper is a program that takes a native data structure and converts it into a YAML stream. A dumper is a stack of stages (aka transforms) that each convert their input from one state to another, in reverse order of the loader.</p> </li> </ul>"},{"location":"doc/vocab/#ys-vocabulary","title":"YS Vocabulary","text":"<ul> <li> <p>mode</p> <p>A YS mode is a set of rules that determine the semantics of a given YAML node by YS. Every YAML node in a stream has one of 3 modes:</p> <ul> <li>bare - Node follows the semantics of a normal YAML loader.   Sub-nodes will always be of bare mode as well.   That is, no code evaluation can ever take place.</li> <li>code - Node is meant to be compiled as code to be evaluated.   The <code>say: 'Hello'</code> mapping pair will print \"Hello\", because the unquoted key   <code>say</code> is a symbol bound to the <code>ys::std/say</code> function.   Any sub-node can be changed to data mode (or bare mode).</li> <li>data - Node is meant to be compiled as having data semantics.   This is similar to bare mode, except any sub-node can change modes to code   mode (or bare mode).</li> </ul> </li> <li> <p>mode tag</p> <p>Unless a YAML/YS document starts with a mode tag, then it is assigned to bare mode and treated as normal YAML. These tags are used to indicate the mode of a node:</p> <ul> <li><code>!YS-v0</code> - Start a document in code mode</li> <li><code>!YS-v0:</code> - Start a document in data mode</li> <li><code>!bare</code> - Make a node have bare mode semantics</li> <li><code>!code</code> - Make a node have code mode semantics</li> <li><code>!data</code> - Make a node have data mode semantics</li> <li><code>!</code> - Toggle between code and data modes (or vice versa)</li> </ul> <p>A <code>!YS-v0</code> or <code>!YS-v0:</code> mode tags must appear before any other mode tag is used in a stream. Each document in a stream must have mode tag or else it is considered bare mode.</p> </li> <li> <p>expression</p> <p>An evaluatable piece of YS code.</p> </li> <li> <p>S-expression</p> <p>Lisp term for a parenthesized list of 1 or more forms where the first form is a function and the rest of the forms are arguments. Any of the forms may themselves be s-expressions.</p> <pre><code>(println (* 6 7))  # =&gt; 42\n</code></pre> <p>YS supports s-expressions, YeS-expressions, pair-expressions and dot-chain expressions.</p> </li> <li> <p>YeS-expression</p> <p>A YS syntax where the function name comes before the opening parentheses and infix operator expressions are allowed:</p> <pre><code>println(6 * 7)\n</code></pre> </li> <li> <p>Pair expression</p> <p>A YS expression as a mapping pair where the function comes first on the LHS. The argument forms can be on either side of the <code>:</code>.</p> <pre><code>println: 6 * 7\n</code></pre> </li> <li> <p>Dot-chain expressions</p> <p>Functions can be applied to values <code>.fn-name()</code>: These are the same:   <pre><code>fn2(fn1(val1 val2))\nval1.fn1(val2).fn2()\nval1.fn1(val2):fn2\n</code></pre></p> <p>The LHS of a dot function call generally becomes the first argument. If there is only one argument then: <code>arg:fn1</code> is short for <code>arg.fn1()</code>.</p> </li> </ul>"},{"location":"doc/yaml/","title":"YAML Basics","text":"<p>YAML was created to make data documents simple (most of the time). It was also created to give people a lot of control over how they write their data.</p> <p>Modern programmers generally have a decent understanding of YAML basics as it ends up in many places in the tech world. That said, there are many lesser well-known YAML concepts and features and YS makes use of most of them.</p> <p>Remember, all valid YS is required to be valid YAML syntax. To write YS well, you'll need to have a solid understanding of YAML concepts and also Clojure concepts.</p> <p>This document will cover all the YAML syntax, concepts and vocabulary that you need to know to write YS effectively.</p> <p>Note</p> <p>When a word or phrase is presented in double quotes here, it is intended to be a YAML vocabulary term that you should commit to memory. These terms are used consistently throughout the YS documentation (and also the YAML specification and other YAML-related writings).</p>"},{"location":"doc/yaml/#yaml-data-model","title":"YAML Data Model","text":"<p>YAML represents the same kinds of data as JSON: \"mappings\", \"sequences\" and \"scalars\".</p> <ul> <li>A \"mapping\" is an unordered collection of key-value pairs where each key is   unique.   Mappings are also known as 'hashes', 'dictionaries', 'objects' or 'associative   arrays' in other languages, but in YAML they are always called mappings.</li> <li>A \"sequence\" is an ordered collection of values.   Sequences are also known as 'arrays', 'lists' or 'vectors' elsewhere.</li> <li>A \"scalar\" is a single value, like a number, string, keyword, boolean or even   a null value.   Scalars are also known as 'atoms' or 'primitives' elsewhere.</li> </ul> <p>YAML adds just a few things to this basic data model:</p> <ul> <li>YAML \"streams\" can consist of one YAML \"document\" (the normal case), multiple   documents separated by <code>---</code> / <code>...</code>, or no documents at all.</li> <li>A YAML \"stream\" is all of the YAML text in a single YAML file or YAML string     passed to a YAML \"loader\" or generated by a YAML \"dumper\".</li> <li>A YAML \"document\" is a single YAML data \"node\".</li> <li>A \"node\" is a single value in the YAML data model: a mapping, sequence or     scalar.</li> <li>Any YAML node in a document can be given a name (called an \"anchor\") and   referred to by that name elsewhere in the document using an \"alias\".</li> <li>An anchor looks like <code>&amp;foo</code> and an alias looks like <code>*foo</code>.</li> <li>Example:     <pre><code>first: &amp;anchor\n  a: mapping\nsecond: *anchor  # Both values are the same mapping: {\"a\": \"mapping\"}.\n</code></pre></li> <li>A mapping key can be any \"kind\" of YAML node, (not just a scalar node like in   JSON).</li> <li>This is not commonly used either in YAML or YS, but it is completely valid.</li> <li>The term \"kind\" is used to refer to those three different YAML node shapes:     \"mapping\", \"sequence\" or \"scalar\".</li> <li>Any YAML node can have a \"explicit tag\".</li> <li>A tag looks like <code>!foo-bar</code> and is used to associate a word or string with     a that YAML node.</li> <li>Tags typically instruct a YAML loader how to interpret the node.</li> <li>Even though it is rare to see tags in YAML, part of the loading process is     to assign a tag to every node that lacks an explicit one.     This process is known as \"implicit tagging\" or \"tag resolution\".</li> <li>In YS, the tags <code>!YS-v0</code> and just <code>!</code> are quite common.     They control the YS \"mode\" of a particular node.</li> </ul>"},{"location":"doc/yaml/#basic-yaml-syntax","title":"Basic YAML Syntax","text":"<p>YAML supports a comment syntax. Comments start with a <code>#</code> and continue to the end of the line. Blank lines are also considered comments. The <code>#</code> must be at the start of the line or preceded by whitespace.</p> <p>We'll show you some YAML examples to illustrate the basic syntax and use YAML comments to explain the concepts as much as possible.</p> <p>Example 1: A YAML stream with several syntax elements:</p> <pre><code># A line starting with `---` is used to begin a new document.\n# It is not required for the first document in a stream.\n# It is common to put any tag or anchor for the top level node on the same\n# line as the `---`.\n\n---\n\n# Let's start with the common mapping and sequence nodes.\n# Mappings are a group of \"pairs\", each consisting of a \"key\" and a \"value\"\n# separated by a colon.\n# Sequences are a group of nodes where each one is prefixed by a dash.\n# Both the colon and the dash must be followed by a whitespace to be valid.\n\n# The top level node of this document is a mapping.\n\n# For the first pair we have a scalar key and a scalar value.\n# Notice how the key is single-quoted and the value is double-quoted.\n\n'first-key': \"first-value\"\n\n# The second pair has another scalar key and scalar value.\n\nsecond-key: second value\n\n# Notice that both of them are unquoted.\n# Scalars of can be expressed with or without quotes.\n# This is very common in YAML and very important in YS.\n\n# The kind of quoting (or lack thereof) is called the scalar's \"style\" in YAML.\n# The different quoting styles have different encoding rules and different\n# semantics.\n# There are actually 5 distinct scalar styles in YAML: plain, single quoted,\n# double quoted, literal and folded.\n# We'll cover these styles in more detail in a second.\n\n# Mapping pair values can be any kind of YAML node.\n# Mappings and sequences can also be used as values and nested to an arbitrary\n# depth.\n# This is accomplished by indenting the nested node using one or more spaces.\n\nthird-key:\n  a: sub-mapping\n  second:\n  - a sequence\n  - of values\n  - a scalar\n  - - sub-sequence\n    - items\n  - another: sub-mapping\n\n  # The sequence value under the key `second` here doesn't seem to be indented\n  # but the leading dash acts as indentation.\n  # This is the preferred style for indenting sequence values of mapping pairs\n  # in YAML, but you can also indent them more if you prefer.\n\n  another sequence:\n  - one\n  - two\n\nHere's what the 5 scalar styles look like:\n\nplain:\n- I'm unquoted and plain\n- I can also span multiple lines\n  where whitespace beteween lines\n  folds to a single space\nsingle quoted:\n- 'I''m single quoted'\n- 'I have one thing that is escapable,\n  the single quote itself '' which\n  is escaped by doubling it'\n- 'Multiline single quoted scalars\n  fold the same way as plain'\ndouble quoted:\n- \"I'm double quoted\"\n- \"I'm the only style capable of encoding\n  any possible string value\"\n- \"I have lots of escapes like \\n and \\t\n  and also \\\" and \\\\\"\n- \"Multiline double quoted scalars\n  fold the same way as plain\"\nliteral: |\n  I'm like a heredoc in Shell or Perl.\n\n  But my scope is determined by indentation.\n  Newlines are preserved as you would expect\n  from a heredoc.\nfolded: &gt;\n  Folded scalars pretty much fold like\n  the others, but you can use them without\n  worry of ` #` or `: ` being special.\n\n  They are the most rarely used scalar style.\n\nIn YS code mode:\n- plain: Used for code expressions\n- single quoted: Used for character strings\n- double quoted: Used for strings with interpolation support\n- literal: Used for template strings including interpolation\n- folded: Not allowed in code mode\n\n# A line with `...` is used to end a document.\n# It's optional, since `---` does the same thing, but you might want to use it\n# for clarity.\n\n...\n\n\n# Here we start a second document in the stream.\n# This one is a top level sequence and it has an anchor and a tag:\n# The `---` indicator is required and you can also use the line to specify the\n# anchor and tag for the top level node.\n\n--- &amp;my-seq-1 !a-tag\n\n# The first sequence item is a scalar string with content of \"first item\".\n- first item\n\n# The second item is another sequence:\n-\n  - one\n  - two\n\n# It is possible, typical and preferred to collapse this like so:\n- - one\n  - two\n\n# The third item is a mapping:\n-\n  foo: bar\n  baz: 42\n\n# This may also be collapsed (and is also preferred) like so:\n\n- foo: bar\n  baz: 42\n\n# This sequence collapsing can be many levels deep:\n\n- - - - foo: bar\n\n# But don't try collapsing multiple mappings.\n# The next line would be an error:\n\n# - foo: bar: baz   # ERROR ': ' not allowed in plain scalars\n\n# A third document in the stream. Note that no `...` was used to end the\n# previous document.\n\n---\n\n# Mappings and sequences can be expressed using a different syntax that looks\n# like JSON.\n# YAML uses curly braces for mappings and square brackets for sequences.\n# These are called \"flow style\" for \"collections\".\n# The normal indented style we've been using is called \"block style\" by\n# comparison.\n# Note: A YAML \"collection\" is the generic term for a node that is either a\n# mapping or a sequence.\n\nkey 1: {x: red,\n        y: blue, z: green}\nkey 2: [red, blue,\n        green]\n\n# If you ever need an empty mapping or sequence, you need to use the following:\n\nempty mapping: {}\nempty sequence: []\n\n# There is actually no way to write empty collections in block style.\n</code></pre>"},{"location":"doc/yaml/#less-common-yaml-syntax","title":"Less Common YAML Syntax","text":"<p>Here's a few YAML syntax variants that you won't see very often. Some of these are used in YS, so it's good to know about them.</p> <pre><code># YAML has a top level \"directive\" syntax.\n# There are only 2 directives defined by the YAML 1.2 specification:\n# This is the first one, the \"YAML directive\".\n# It simply specifies the version of the YAML specification in play.\n\n%YAML 1.2\n\n# The second directive is the \"TAG directive\".\n# It allows you to specify a shorthand for a tag URI.\n\n%TAG !ys! tag:yamlscript.org,2022:\n\n# To date, directives are not used in YS.\n\n# The `---` indicator is required to start a new document if you have used any\n# directives (even on the first document).\n\n---\n\n# YAML allows a mapping key to be any node, not just a scalar.\n# In other words it allows collections or even aliases to be used as keys.\n\n- &amp;map1\n  a: value\n# Here it is obvious that the key is a mapping.\n- *map1 : 42\n# Here we are using YAML's \"explicit key\" syntax (`?`) to specify the key.\n- ? [a, flow, sequence]\n  : 42\n# We can use `?` with block collections too.\n- ? a: block\n    mapping: key\n  : 43\n# We can even use it for literals scalar keys.\n- ? |-\n    a literal\n    scalar key\n  : 44\n\n---\n\n# The collection key does have a good use case in YS.\n# Consider this `for` loop:\n\nfor a foo(), b bar(), c [1 2 3]:\n  say: a + b + c\n\n# YS requires that the `for [\u2026]` key be a plain scalar, and YAML\n# requires that plain scalar keys need to be a single line.\n# This could lead to unreadable code if we our \"for binding\" is complex.\n\n# Bute can also do it like this:\n\nfor:\n  ? a: foo()\n    b: bar()\n    c: [1 2 3]\n  : say: a + b\n\n# Which you might find to be clearer.\n</code></pre>"},{"location":"doc/yaml/#see-also","title":"See Also","text":"<ul> <li>The yaml.info Site\u00a0 </li> <li>Common YAML / YS Gotchas</li> </ul>"},{"location":"doc/yes/","title":"YeS Expressions","text":"<p>Lisp has the concept of S-Expressions\u00a0  (aka <code>sexpr</code>s), nested parenthesized expressions where the parentheses contain a function (usually a symbol bound to a function) followed by its arguments.</p> <p>YS has a concept called \"YeS Expressions\" (aka <code>ysexpr</code>s) which offer alternate ways to write sexprs in a style that feels more familiar to non-Lisp language expressions.</p> <p>Note</p> <p>In general, YS supports writing code as sexprs, ysexprs or as block mapping pairs. Nested expressions can combine any of those forms. It's up to the programmer to decide which works best for them in any given context.</p> <pre><code>(def var1 (sqrt (+ (* 3 4) 5)))\n</code></pre> <p>The equivalent code in Python would be:</p> <pre><code>var1 = sqrt(3 * 4 + 5)\n</code></pre> <p>In YS, we could write:</p> <pre><code>var1 =: sqrt((3 * 4) + 5)\n</code></pre> <p>There are 3 notable transformations happening here:</p> <ul> <li>Functions named by a word can be placed before the opening paren instead of   inside it.   e.g. <code>a(b c)</code> translates to <code>(a b c)</code>.   Note that no whitespace can come between the <code>a</code> and the <code>(</code>.</li> <li>Prefix operations can be written infix.   e.g. <code>(a + b)</code> translates to <code>(+ a b)</code>.   Triplets with an operator (punctuation) symbol in the middle get this   treatment.</li> <li>Variable assignment (aka symbol binding) can be written using <code>=:</code> YAML   mapping pairs.   e.g. <code>a =: b + c</code> translates to <code>(def a (+ b c))</code>.   Note that whitespace is required on both sides of the <code>=:</code>.</li> </ul> <p>We'll discuss the a few more details of each of these YeS expression transforms below.</p> <p>Note</p> <p>YS has many other transformations that strive to make YS code clean and easy to read and understand. YeS expression transformations are among the most commonly used.</p>"},{"location":"doc/yes/#prefix-call-notation","title":"Prefix Call Notation","text":"<p>The most common way to call a function in non-Lisp programming languages is <code>a()</code>, <code>a(b)</code>, <code>a(b c)</code> etc where <code>a</code> is the name of a function and <code>b</code> and <code>c</code> are arguments that the function is called with. Lisp languages use the same format but put the <code>a</code> inside the parens.</p> <p>YS lets you do either. Again the <code>a</code> must be next to the <code>(</code>. IOW, <code>a (b c)</code> is not the same as <code>a(b c)</code>!</p> <p>Another way to write the function call <code>(a b c)</code> in YS is to use it in a mapping pair context:</p> <pre><code>a: b c\n# Or sometimes:\na b: c\n</code></pre>"},{"location":"doc/yes/#infix-operator-notation","title":"Infix Operator Notation","text":"<p>Lisps write binary operator expressions like:</p> <pre><code>(+ a 5)  ;; a + 5\n(&gt; a 5)  ;; a &gt; 5\n</code></pre> <p>That makes sense because <code>+</code> and <code>&gt;</code> are just ordinary Lisp symbols bound to addition and greater-than functions.</p> <p>One advantage of this prefix notation is that this operations can take more than 2 arguments:</p> <pre><code>(+ a b c d)  ;; a + b + c + d\n(&gt; a b c d)  ;; a &gt; b &gt; c &gt; d  or  (a &gt; b) &amp;&amp; (b &gt; c) &amp;&amp; (c &gt; d)\n</code></pre> <p>YeS expressions allow you to do these things:</p> <pre><code>=&gt;: a + b        # (+ a b)\n=&gt;: a + b + c    # (+ a b c)\n=&gt;: a + b &gt; c    # ERROR - no operator mixing; no implicit precedence in YS\n=&gt;: (a + c) &gt; c  # (&gt; (+ a b) c) - Fine with parens\n</code></pre> <p>Note that we didn't need any parentheses around <code>a + b</code>. When a YAML plain scalar with an operator triplet (or multiple forms separated by the same operator) the parentheses are implied and thus optional. The parentheses are implied in a few other contexts as well like:</p> <pre><code>if a &gt; b: c d\n# Equivalent to:\nif (a &gt; b): c d\n</code></pre>"},{"location":"doc/yes/#when-operators-are-arguments","title":"When Operators are Arguments","text":"<p>Every once in a while you might want to pass an operator as an argument to a function call triplet like <code>(apply + numbers)</code> and YS would wrongly translate that to <code>(+ apply numbers)</code>.</p> <p>This is easily avoided by using the prefix call notation described above: <code>apply(+ numbers)</code>. It is also avoided when using the block mapping pair form:</p> <pre><code>apply +: numbers\n</code></pre> <p>Also note that the operator switching only applies to triplet forms, so expressions like <code>(a +)</code> and <code>(a + b c)</code> are never affected.</p>"},{"location":"doc/yes/#assignment-symbol-binding-expressions","title":"Assignment (Symbol Binding) Expressions","text":"<p>In many programming languages, like Python for instance, it's common to see things like:</p> <pre><code>a = b(c)\n</code></pre> <p>where the evaluation result of the function <code>b(c)</code> is assigned (aka bound) to the variable (or symbol) <code>a</code>.</p> <p>In Clojure you would use a <code>def</code> form:</p> <pre><code>(def a (b c))\n</code></pre> <p>Unless it was inside a function scope, in which case you would use a <code>let</code> form:</p> <pre><code>(defn f [b c]\n  (let [a (b c)]\n    (d a)))\n</code></pre> <p>In YS you can write them both the same way:</p> <pre><code>a =: b(c)\n# and\ndefn f(b c):\n  a =: b(c)\n  d: a\n</code></pre> <p>In Clojure you can define multiple <code>let</code> bindings in a single <code>let</code> form.</p> <pre><code>(defn f [a]\n  (let [b (inc a)\n        c (dec a)]\n    (d b c)))\n</code></pre> <p>In YS you can do the same thing:</p> <pre><code>defn f(a):\n  b =: inc(a)\n  c =: dec(a)\n  d: b c\n</code></pre> <p>The YS compiler joins consecutive <code>=:</code> pairs into a single <code>let</code> form, resulting in the same Clojure code as the example above.</p> <p>In Clojure you can bind multiple symbols at once using destructuring:</p> <pre><code>(defn f []\n  (let [[a b] (c)]\n    (g a b)))\n</code></pre> <p>This binds <code>a</code> and <code>b</code> to the first two elements of the sequence returned by calling <code>c</code>.</p> <p>Note that this works for a <code>let</code> expression but not for a <code>def</code> expression:</p> <pre><code>(def [a b] (c))  ;; Syntax error\n</code></pre> <p>In YS it works fine:</p> <pre><code>-[a b] =: c()\n</code></pre>"},{"location":"doc/yes/#conclusion","title":"Conclusion","text":"<p>YeS Expressions are a key way to help you write YS code that looks more like the code you're used to writing in non-Lisp languages, while still retaining the full power of Lisp (Clojure). It's your choice how you want your code to look, and YS gives you many options for that.</p> <p>No matter what your valid YS code looks like, it always compiles to valid Lisp, which makes it extremely reliable to reason about.</p> <p>The power of Lisp is that its input expressions almost completely match the internal evaluation forms that it compiles to. It's very obvious what's going on under the hood, because it's the same as what you see on the outside. This is called homoiconicity\u00a0 .</p> <p>In dynamic languages like JavaScript, Python, Ruby or Perl you don't really get to see what your code turns into before it is evaluated.</p> <p>YS tries to offer a very flexible set of coding styles that always compile to Lisp's extremely robust evaluation form.</p>"},{"location":"doc/ys-clj/","title":"Replaced Clojure Functions","text":"<p>A number of standard functions from Clojure's standard library <code>clojure::core</code> have been replaced by functions in the <code>ys::std</code> library. In general the replacements have the same intent as the original functions, but from a YS perspective.</p> <p>When you absolutely need the original Clojure functions, they are available in this <code>ys::clj</code> library. These functions are automatically available in YAMLSCript by using the <code>clj/</code> prefix.</p>"},{"location":"doc/ys-clj/#functions","title":"Functions","text":"<p>The documentation for these functions is available in the Clojure documentation web site, so we include a link to there in each definition.</p> <ul> <li> <p><code>clj/compile</code> \u2014 In Clojure\u00a0  the   <code>compile</code> function compiles a namespace into a set of class files.   In YS it converts a YS source code string into a   Clojure source code string.</p> </li> <li> <p><code>clj/load</code> \u2014 In Clojure\u00a0  the   <code>load</code> function loads a file from the classpath.   In YS it's an alias for <code>load-file</code>(below).</p> </li> <li> <p><code>clj/load-file</code> \u2014 In Clojure\u00a0    the <code>load-file</code> function loads a Clojure file from a given file path.   In YS it loads a YS file from a given file path.</p> </li> <li> <p><code>clj/num</code> \u2014 In Clojure\u00a0  the <code>num</code>   function converts a Java number to a Clojure number.   In YS it converts a numeric string to a number.</p> </li> <li> <p><code>clj/use</code> \u2014 In Clojure\u00a0  the <code>use</code>   function is used to refer a namespace into the current namespace.   In YS it loads a YS or Clojure library from <code>YSPATH</code>.</p> </li> </ul>"},{"location":"doc/ys-csv/","title":"CSV and TSV","text":"<p>This library provides functions for reading and writing the CSV\u00a0  and TSV\u00a0  formats.</p> <ul> <li><code>read(S)</code> \u2014 Short name for <code>csv/read-csv(S)</code></li> <li><code>read-csv(s)</code> \u2014 Convert a CSV string to a list of lists</li> <li><code>read-tsv(s)</code> \u2014 Convert a TSV string to a list of lists</li> <li><code>write(S)</code> \u2014 Short name for <code>csv/write-csv(S)</code></li> <li> <p><code>write-csv(LoL)</code> \u2014 Convert a list of lists to a CSV string |</p> </li> <li> <p><code>write-tsv(LoL)</code> \u2014 Convert a list of lists to a TSV string</p> </li> </ul>"},{"location":"doc/ys-json/","title":"JSON Library","text":"<ul> <li><code>load(S)</code> \u2014 Load a JSON string to a native data structure.</li> <li><code>dump(X)</code> \u2014 Dump a native data structure to a JSON string.</li> <li><code>pretty(X)</code> \u2014 Dump a native data structure to a pretty JSON string.</li> </ul>"},{"location":"doc/ys-libs/","title":"YS Builtin Libraries","text":"<ul> <li><code>ys::clj</code> \u2014 Original Clojure functions replaced by <code>ys::std</code></li> <li><code>ys::json</code> \u2014 JSON load and dump functions</li> <li><code>ys::std</code> \u2014 YS standard library</li> <li><code>ys::taptest</code> \u2014 TAP Test library</li> <li><code>ys::yaml</code> \u2014 YAML load and dump functions</li> <li><code>ys::ys</code> \u2014 Using YS in YS</li> </ul>"},{"location":"doc/ys-std/","title":"Standard Library","text":"<p>YS has over 1000 functions that are always available to your YS programs without needing to explicitly import (<code>use</code>) any libraries. Over 800 of these can be used without a namespace prefix like <code>str/</code> or <code>math/</code>.</p> <p>Most of these functions are from the Clojure standard library\u00a0 , but YS also has the <code>ys::std</code> standard library that provides additional functions.</p> <p>This document describes the <code>ys::std</code> functions and how to use them. It also links to related functions in the Clojure core library.</p> <p>Note</p> <p>In a few cases, the YS standard library replaces some Clojure functions with a version more suited to YS. In those cases, the original Clojure function is still available in the <code>ys::clj</code> namespace.</p>"},{"location":"doc/ys-std/#string-functions","title":"String functions","text":"<ul> <li><code>base64-decode(Str) \u2192 Str</code> \u2014 Decode a base64 string</li> <li><code>base64-encode(Str) \u2192 Str</code> \u2014 Encode a string to base64</li> <li><code>base64-points(Str) \u2192 [Int]</code> \u2014 Decode a base64 string to code points</li> <li><code>base64(Str) \u2192 Str</code> \u2014 Alias of base64-encode</li> <li> <p><code>blank?(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/blank?</code> </p> <p>True if string is nil, empty or only whitespace</p> </li> <li> <p><code>chomp(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/trim-newline</code> </p> <p>Remove trailing newlines</p> </li> <li> <p><code>chop(Str) \u2192 Str</code> \u2014 Remove last character</p> </li> <li> <p><code>ends?(Str) \u2192 B</code> \u2014 Alias of <code>clojure.string/ends-with?</code> </p> <p>True if string ends with suffix</p> </li> <li> <p><code>escape(Str {Chr:Str}) \u2192 Str</code> \u2014 Alias of <code>clojure.string/escape</code> </p> <p>Escape special characters in a string</p> </li> <li> <p><code>index(Str Str) \u2192 Int</code> \u2014 Alias of <code>clojure.string/index-of</code> </p> <p>Find index of substring</p> </li> <li> <p><code>join([Str]) \u2192 Str</code> \u2014 Join strings or seqs with <code>\"\"</code></p> </li> <li><code>join(sep [Str]) \u2192 Str</code> \u2014 Join strings or seqs with a separator</li> <li><code>joins([Str]) \u2192 Str</code> \u2014 Join strings with <code>\" \"</code></li> <li> <p><code>lc(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/lower-case</code> </p> <p>Lowercase a string</p> </li> <li> <p><code>lines(Str) \u2192 [Str]</code> \u2014 Split a string into lines</p> </li> <li><code>pretty(Str) \u2192 Str</code> \u2014 Pretty print a value</li> <li><code>replace(X) \u2192 X</code> \u2014 Alias of <code>clojure.core/replace</code> </li> <li> <p><code>replace(Str Rgx Str?) \u2192 Str</code> \u2014 Alias of <code>clojure.string/replace</code> </p> <p>Replace all occurrences of regex with new string (default \"\")</p> </li> <li> <p><code>replace1(Str Rgx Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/replace-first</code> </p> <p>Replace first occurrence of regex with new string</p> </li> <li> <p><code>rindex(Str Str) \u2192 Int</code> \u2014 Alias of <code>clojure.string/last-index-of</code> </p> <p>Find last index of substring</p> </li> <li> <p><code>split(Str) \u2192 [Str]</code> \u2014 Like <code>clojure.string/split</code> </p> <p>Split on <code>\"\"</code></p> </li> <li> <p><code>split(Str rgx) \u2192 [Str]</code> \u2014 Alias of <code>clojure.string/split</code> </p> <p>Split a string by a regex</p> </li> <li> <p><code>starts?(Str Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/starts-with?</code> </p> <p>True if string starts with prefix</p> </li> <li> <p><code>substr(Str Int Int?) \u2192 Str</code> \u2014 Substring function with Perl semantics </p> <p>Offset is 0-based, negative offset counts from end; Optional length is from offset and defaults to end of string; Negative length counts from end of string</p> </li> <li> <p><code>text([Str]) \u2192 Str</code> \u2014 Join list of strings with newlines, adding a newline at the end</p> </li> <li> <p><code>trim(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/trim</code> </p> <p>Trim whitespace from both ends</p> </li> <li> <p><code>triml(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/triml</code> </p> <p>Trim whitespace from left end</p> </li> <li> <p><code>trimr(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/trimr</code> </p> <p>Trim whitespace from right end</p> </li> <li> <p><code>uc(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/upper-case</code> </p> <p>Uppercase a string</p> </li> <li> <p><code>uc1(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/capitalize</code> </p> <p>Uppercase the first character</p> </li> <li> <p><code>words(Str) \u2192 [Str]</code> \u2014 Split a string into words (split on whitespace)</p> </li> </ul> <p>See also: https://clojuredocs.org/quickref#strings-characters\u00a0 </p>"},{"location":"doc/ys-std/#collection-functions","title":"Collection functions","text":"<ul> <li> <p><code>diff(Col Col) \u2192 [Str Str Str]</code> \u2014 Alias of <code>clojure.data/diff</code> </p> <p>Return the difference of two collections</p> </li> <li> <p><code>flat(Vec) \u2192 Vec</code> \u2014 Like <code>clojure.core/flatten</code> </p> <p>Only flattens one level</p> </li> <li> <p><code>get+(Col Key) \u2192 X</code> \u2014 Get a string, keyword or symbol from a map or sequence</p> </li> <li><code>grep(Fn Col) \u2192 Col</code> \u2014 Filter a collection by a predicate function</li> <li><code>has?(Col) \u2192 Fn</code> \u2014 Returns a partial function closed over Col</li> <li> <p><code>has?(Col X) \u2192 B</code> \u2014 True if collection has X </p> <p>Works with strings, maps and sequences</p> </li> <li> <p><code>in?(Col) \u2192 Fn</code> \u2014 Returns a partial function closed over Col</p> </li> <li> <p><code>in?(X Col) \u2192 B</code> \u2014 True if X is in collection </p> <p>Works with strings, maps and sequences</p> </li> <li> <p><code>omap([X]) \u2192 Omap</code> \u2014 Create an ordered map</p> </li> <li><code>reverse(Col) \u2192 Col</code> \u2014 Reverse a string, vector or sequence</li> <li> <p><code>rng(Int Int) \u2192 [Int]</code> \u2014 Create a range of numbers or characters, Y is inclusive</p> <p>If X is greater than Y, the range is descending</p> </li> <li> <p><code>slice(Col [Key]) \u2192 [X]</code> \u2014 Get a sequence of values from the keys</p> </li> </ul> <p>See also: https://clojuredocs.org/quickref#collections\u00a0 </p>"},{"location":"doc/ys-std/#math-functions","title":"Math functions","text":"<ul> <li><code>add(Num*) \u2192 Num</code> \u2014 Alias of <code>clojure.core/+</code> </li> <li><code>sub(Num+) \u2192 Num</code> \u2014 Alias of <code>clojure.core/-</code> </li> <li><code>mul(Num*) \u2192 Num</code> \u2014 Alias of <code>clojure.core/*</code> </li> <li><code>div(Num+) \u2192 Num</code> \u2014 Division function that returns a float if needed</li> <li> <p><code>add+(X+) \u2192 X</code> \u2014 Polymorphic addition function</p> <p>Adds numbers, strings, chars, sequences, maps, sets and functions</p> </li> <li> <p><code>sub+(X+) \u2192 X</code> \u2014 Polymorphic subtraction function</p> <p>Subtracts numbers, strings, chars, sequences, maps and sets</p> </li> <li> <p><code>mul+(X+) \u2192 X</code> \u2014 Polymorphic multiplication function</p> <p>Multiplies numbers, strings and sequences</p> </li> <li> <p><code>digits(Str) \u2192 [Int]</code> \u2014 Convert a string of digits to a sequence of numbers</p> </li> <li> <p><code>floor(Num) \u2192 Num</code> \u2014 Alias of CM/floor </p> <p>Round down to the nearest integer</p> </li> <li> <p><code>pow(Num Num+) \u2192 Num</code> \u2014 Raise a number to a power</p> </li> <li><code>sqr(Num) \u2192 Num</code> \u2014 Square a number</li> <li><code>cube(Num) \u2192 Num</code> \u2014 Cube a number</li> <li><code>sqrt(Num) \u2192 Num</code> \u2014 Square root of a number</li> <li><code>sum([Num]) \u2192 Num</code> \u2014 Sum a sequence of numbers</li> </ul> <p>See also: https://clojure.github.io/clojure/clojure.math-api.html\u00a0 </p>"},{"location":"doc/ys-std/#infix-operators","title":"Infix operators","text":"<ul> <li><code>.</code> \u2014 For chaining functions (<code>foo.bar.baz()</code>)</li> <li><code>:</code> \u2014 This <code>foo:bar</code> is same as <code>foo.bar()</code></li> <li><code>+</code> \u2014 For <code>add+</code></li> <li><code>-</code> \u2014 For <code>sub+</code></li> <li><code>*</code> \u2014 For <code>mul+</code></li> <li><code>/</code> \u2014 For <code>div</code></li> <li><code>**</code> \u2014 For <code>pow</code></li> <li><code>..</code> \u2014 For <code>rng</code></li> <li><code>=~</code> \u2014 For <code>re-find</code></li> <li><code>!~</code> \u2014 For <code>re-find + not</code></li> <li><code>==</code> \u2014 For <code>eq</code></li> <li><code>!=</code> \u2014 For <code>ne</code></li> <li><code>&gt;</code> \u2014 For <code>gt</code></li> <li><code>&gt;=</code> \u2014 For <code>ge</code></li> <li><code>&lt;</code> \u2014 For <code>lt</code></li> <li><code>&lt;=</code> \u2014 For <code>le</code></li> <li><code>&amp;&amp;</code> \u2014 For <code>and</code></li> <li><code>||</code> \u2014 For <code>or</code></li> <li><code>&amp;&amp;&amp;</code> \u2014 For <code>and?</code></li> <li><code>|||</code> \u2014 For <code>or?</code></li> </ul>"},{"location":"doc/ys-std/#chaining-short-forms","title":"Chaining short forms","text":"<ul> <li><code>value.#</code> \u2014 Short for <code>value.count()</code></li> <li><code>value.$</code> \u2014 Short for <code>value.last()</code></li> <li><code>value.++</code> \u2014 Short for <code>value.inc()</code></li> <li><code>value.--</code> \u2014 Short for <code>value.dec()</code></li> <li><code>value.?</code> \u2014 Short for <code>value.truey?()</code></li> <li><code>value.!</code> \u2014 Short for <code>value.falsey?()</code></li> <li><code>value.??</code> \u2014 Short for <code>value.boolean()</code></li> <li><code>value.!!</code> \u2014 Short for <code>value.not()</code></li> <li><code>value.@</code> \u2014 Short for `value.deref()</li> <li> <p><code>value.&gt;&gt;&gt;</code> \u2014 Short for <code>value.DBG()</code></p> <p>Print value/data to stderr and return the value unchanged</p> </li> </ul>"},{"location":"doc/ys-std/#control-functions","title":"Control functions","text":"<ul> <li> <p><code>call(Fn X*) \u2192 X</code> \u2014 Call a function or value</p> <p>Function can be a string, symbol or function</p> </li> <li> <p><code>die(Msg)</code> \u2014 Idiomatic error function</p> </li> <li><code>each(Bindings Body) \u2192 X</code> \u2014 Non-lazy <code>clojure.core/for</code> </li> <li><code>eval(Str) \u2192 X</code> \u2014 Evaluate a string as YS code</li> <li><code>exit(RC=0)</code> \u2014 Exit the program</li> <li><code>if(Cond Then Else) \u2192 X</code> \u2014 Functional if used in dot chaining</li> <li><code>sleep(Secs) \u2192 X</code> \u2014 Sleep for a number of seconds</li> <li> <p><code>value(X) \u2192 X</code> \u2014 Get var value from var, symbol or string</p> <p>Often used to convert a string to a function.</p> </li> <li> <p><code>when+(Cond Body) \u2192 X</code> \u2014 Like <code>clojure.core/when</code> </p> <p>Binds the result of the condition to the <code>_</code> symbol</p> </li> </ul> <p>See also: https://clojuredocs.org/quickref#flow-control\u00a0 </p>"},{"location":"doc/ys-std/#function-functions","title":"Function functions","text":"<ul> <li><code>defn flip(Fn) \u2192 X</code> \u2014 Flip the arguments of a function</li> </ul>"},{"location":"doc/ys-std/#regex-functions","title":"Regex functions","text":"<ul> <li><code>=~ X</code> \u2014 Infix re-find operator</li> <li><code>!~ X</code> \u2014 Infix re-find complement operator</li> </ul> <p>See also: https://clojuredocs.org/quickref#regular-expressions\u00a0 </p>"},{"location":"doc/ys-std/#io-functions","title":"I/O functions","text":"<ul> <li><code>err(Str*) \u2192 nil</code> \u2014 Print to stderr</li> <li> <p><code>out(Str*) \u2192 nil</code> \u2014 Print to stdout</p> <p>Flushes stdout after printing</p> </li> <li> <p><code>pp(X) \u2192 nil</code> \u2014 Pretty print a value</p> </li> <li> <p><code>print(Str*) \u2192 nil</code> \u2014 Print to stdout without newline</p> <p>Flushes stdout after printing</p> </li> <li> <p><code>read(path) \u2192 Str</code> \u2014 Alias of <code>clojure.core/slurp</code> </p> <p>Read a file into a string</p> </li> <li> <p><code>say(Str*) \u2192 nil</code> \u2014 Print to stdout with newline</p> </li> <li> <p><code>warn(Str*) \u2192 nil</code> \u2014 Print to stderr with newline</p> <p>Flushes stderr after printing</p> </li> <li> <p><code>write(path Str) \u2192 nil</code> \u2014 Alias of <code>clojure.core/spit</code> </p> <p>Write a string to a file</p> </li> </ul>"},{"location":"doc/ys-std/#shorter-named-alias-functions","title":"Shorter named alias functions","text":"<ul> <li><code>a(X) \u2192 X</code> \u2014 Alias of <code>clojure.core/identity</code> </li> <li><code>len(X) \u2192 Int</code> \u2014 Alias of <code>clojure.core/count</code> </li> </ul>"},{"location":"doc/ys-std/#quoting-functions","title":"Quoting functions","text":"<ul> <li><code>q(form) \u2192 X</code> \u2014 Alias of <code>clojure.core/quote</code> </li> <li><code>qr(str) \u2192 Rgx</code> \u2014 Alias of <code>clojure.core/re-pattern</code> </li> <li><code>qw(symbols) \u2192 [Str]</code> \u2014 Turn symbols into a vector of strings</li> </ul>"},{"location":"doc/ys-std/#named-function-for-infix-operators","title":"Named function for infix operators","text":"<ul> <li><code>eq</code> \u2014 Alias of <code>clojure.core/=</code> </li> <li><code>ne</code> \u2014 Alias of <code>clojure.core/not=</code> </li> <li><code>gt</code> \u2014 Alias of <code>clojure.core/&gt;</code> </li> <li><code>ge</code> \u2014 Alias of <code>clojure.core/&gt;=</code> </li> <li><code>lt</code> \u2014 Alias of <code>clojure.core/&lt;</code> </li> <li><code>le</code> \u2014 Alias of <code>clojure.core/&lt;=</code> </li> </ul>"},{"location":"doc/ys-std/#common-type-conversion-functions","title":"Common type conversion functions","text":"<ul> <li><code>to-bool(X) \u2192 B</code> \u2014 Convert X to a boolean</li> <li><code>to-char(X) \u2192 Chr</code> \u2014 Convert X to a character</li> <li><code>to-float(X) \u2192 Flt</code> \u2014 Convert X to a float</li> <li><code>to-int(X) \u2192 Int</code> \u2014 Convert X to an integer</li> <li><code>to-keyw(X) \u2192 Kwd</code> \u2014 Convert X to a keyword</li> <li><code>to-list(X) \u2192 List</code> \u2014 Convert X to a list</li> <li><code>to-map(X) \u2192 Map</code> \u2014 Convert X to a map</li> <li><code>to-num(X) \u2192 Num</code> \u2014 Convert X to a number</li> <li><code>to-omap(X) \u2192 Omap</code> \u2014 Convert X to an ordered map</li> <li><code>to-set(X) \u2192 Set</code> \u2014 Convert X to a set</li> <li><code>to-str(X) \u2192 Str</code> \u2014 Convert X to a string</li> <li> <p><code>to-type(X) \u2192 Str</code> \u2014 Convert X to a string name of its type:</p> <p><code>\"atom\"</code>, <code>\"bool\"</code>, <code>\"char\"</code>, <code>\"class\"</code>, <code>\"float\"</code>, <code>\"fun\"</code>, <code>\"int\"</code>, <code>\"keyw\"</code>, <code>\"list\"</code>, <code>\"map\"</code>, <code>\"nil\"</code>, <code>\"num\"</code>, <code>\"rgx\"</code>, <code>\"seq\"</code>, <code>\"set\"</code>, <code>\"str\"</code>, <code>\"sym\"</code>, <code>\"var\"</code>, <code>\"vec\"</code></p> </li> <li> <p><code>to-vec(X) \u2192 Vec</code> \u2014 Convert X to a vector</p> </li> </ul>"},{"location":"doc/ys-std/#single-character-casting-functions","title":"Single character casting functions","text":"<ul> <li><code>B(X)</code> \u2014 Convert to a boolean</li> <li><code>C(X)</code> \u2014 Convert to a character</li> <li><code>D(X)</code> \u2014 Deref an atom</li> <li><code>F(X)</code> \u2014 Convert to a float</li> <li><code>I(X)</code> \u2014 Convert to an integer</li> <li><code>K(X)</code> \u2014 Convert to a keyword</li> <li><code>L(X)</code> \u2014 Convert to a list</li> <li><code>M(X)</code> \u2014 Convert to a map</li> <li><code>N(X)</code> \u2014 Convert to a number</li> <li><code>O(X)</code> \u2014 Convert to an ordered map</li> <li><code>S(X)</code> \u2014 Convert to a set</li> <li><code>T(X)</code> \u2014 Convert to a type name string</li> <li><code>V(X)</code> \u2014 Convert to a vector</li> <li><code>L+(X*) \u2192 List</code> \u2014 Convert to a list</li> <li><code>M+(X*) \u2192 Map</code> \u2014 Convert to a map</li> <li><code>O+(X*) \u2192 Omap</code> \u2014 Convert to an ordered map</li> <li><code>V+(X*) \u2192 Vec</code> \u2014 Convert to a vector</li> </ul>"},{"location":"doc/ys-std/#alternate-truth-functions","title":"Alternate truth functions","text":"<ul> <li><code>falsey?(X) \u2192 X</code> \u2014 True if X is falsey - 0, nil, false, empty</li> <li><code>F?(X)</code> \u2014 Short for <code>falsey?</code></li> <li><code>truey?(X) \u2192 X</code> \u2014 True if X is not falsey</li> <li><code>T?(X)</code> \u2014 Short for <code>truey?</code></li> <li><code>or?(X X+) \u2192 X</code> \u2014 Return first truey value or nil</li> <li><code>and?(X X+) \u2192 X</code> \u2014 Return last truey value or nil</li> </ul>"},{"location":"doc/ys-std/#file-system-functions","title":"File system functions","text":"<ul> <li><code>fs-d(Path) \u2192 B</code> \u2014 True if path is a directory</li> <li><code>fs-e(Path) \u2192 B</code> \u2014 True if path exists</li> <li><code>fs-f(Path) \u2192 B</code> \u2014 True if path is a regular file</li> <li><code>fs-l(Path) \u2192 B</code> \u2014 True if path is a symbolic link</li> <li><code>fs-r(Path) \u2192 B</code> \u2014 True if path is readable</li> <li><code>fs-s(Path) \u2192 B</code> \u2014 True if path is not empty</li> <li><code>fs-w(Path) \u2192 B</code> \u2014 True if path is writable</li> <li><code>fs-x(Path) \u2192 B</code> \u2014 True if path is executable</li> <li><code>fs-z(Path) \u2192 B</code> \u2014 True if path is empty</li> <li><code>fs-abs(Path) \u2192 Path</code> \u2014 Get the absolute path</li> <li><code>fs-abs?(Path) \u2192 B</code> \u2014 True if path is absolute</li> <li><code>fs-basename(Path Ext?) \u2192 B</code> \u2014 Get the file name of a path, without extension</li> <li><code>fs-dirname(Path) \u2192 Dir</code> \u2014 Get the directory name of a path</li> <li><code>fs-filename(Path) \u2192 File</code> \u2014 Get the file name of a path</li> <li><code>fs-glob(Path) \u2192 [Path]</code> \u2014 Glob a path</li> <li><code>fs-ls(dir) \u2192 [File]</code> \u2014 List a directory</li> <li><code>fs-mtime(file) \u2192 Int</code> \u2014 Get the modification time of a file</li> <li><code>fs-rel(Path) \u2192 Path</code> \u2014 Get the relative path</li> <li><code>fs-rel?(Path) \u2192 B</code> \u2014 True if path is relative</li> <li><code>fs-which(name) \u2192 B</code> \u2014 Find the path of an executable</li> </ul> <p>See also: https://github.com/babashka/fs/blob/master/API.md\u00a0 </p>"},{"location":"doc/ys-std/#datetime-functions","title":"Date/Time functions","text":"<ul> <li><code>now() \u2192 Instant</code> \u2014 Returns <code>java.time.Instant</code> object</li> </ul>"},{"location":"doc/ys-std/#security-functions","title":"Security functions","text":"<ul> <li><code>md5(S) \u2192 X</code> \u2014 Calculate the MD5 hash of a string</li> <li><code>sha1(S) \u2192 X</code> \u2014 Calculate the SHA-1 hash of a string</li> <li><code>sha256(S) \u2192 X</code> \u2014 Calculate the SHA-256 hash of a string</li> </ul>"},{"location":"doc/ys-std/#ipc-functions","title":"IPC functions","text":"<ul> <li><code>exec(Cmd Str*) \u2192 Result</code> \u2014 Execute a command</li> <li><code>process(Cmd Str*) \u2192 Result</code> \u2014 Execute a command</li> <li><code>sh(Cmd Str*) \u2192 Result</code> \u2014 Execute a command</li> <li><code>shell(Cmd Str*) \u2192 Result</code> \u2014 Execute a command</li> <li><code>shout(Cmd Str*) \u2192 Result</code> \u2014 Execute a command and return the output</li> </ul> <p>See also: https://github.com/babashka/process#readme\u00a0 </p>"},{"location":"doc/ys-std/#external-library-functions","title":"External library functions","text":"<ul> <li><code>use-pod(pod-name version) \u2192 nil</code> \u2014 Load an external library pod</li> </ul>"},{"location":"doc/ys-std/#http-functions","title":"HTTP functions","text":"<ul> <li><code>curl(URL) \u2192 Str</code> \u2014 Get a URL and return the body</li> </ul>"},{"location":"doc/ys-std/#yaml-document-result-stashing-functions","title":"YAML document result stashing functions","text":"<ul> <li> <p><code>stream() \u2192 X</code> \u2014 Mapping of document results</p> <p>The symbol <code>_</code> at the top level compiles to <code>(stream)</code></p> </li> </ul>"},{"location":"doc/ys-std/#atom-functions","title":"Atom functions","text":"<ul> <li><code>atom() \u2192 Atom</code> \u2014 Create an atom with a nil value</li> <li><code>atom(X) \u2192 Atom</code> \u2014 Create an atom with a value X</li> <li> <p><code>reset(Atom X) \u2192 X</code> \u2014 Alias of <code>clojure.core/reset!</code> </p> <p>Set the value of an atom</p> </li> <li> <p><code>swap(Atom Fn Arg*) \u2192 X</code> \u2014 Alias of <code>clojure.core/swap!</code> </p> <p>Update the value of an atom</p> </li> </ul>"},{"location":"doc/ys-std/#special-functions","title":"Special functions","text":"<ul> <li> <p><code>source(X*) \u2192 nil</code> \u2014 Run a YS file as a Bash script</p> <p>Acts like <code>clojure.core/comment.</code>  Does nothing in YS. Intended for Bash.</p> </li> </ul>"},{"location":"doc/ys-std/#see-also","title":"See Also","text":"<ul> <li>The <code>ys::std</code> source code\u00a0 </li> <li>The <code>clojure::core</code> source code\u00a0 </li> </ul>"},{"location":"doc/ys-taptest/","title":"YS TAP Testing Library","text":"<p>This library provides an implementation of the Test Anything Protocol (TAP)\u00a0  for YS.</p> <p>It's a really clean way to write unit tests for your YS code.</p> <p>Here's an example of a simple test file (test-1.t):</p> <pre><code>#!/usr/bin/env ys-0\n\nrequire ys::taptest: test done\n\nhash1 =::\n  foo: one\n  bar: two\n\nhash2 =::\n  bar: three\n\ntest::\n- name: Test merge\n  code: hash1.merge(hash2)\n  want:\n    foo: one\n    bar: three\n\n- name: Count keys\n  code: hash1.keys().count()\n  want: 2\n\ndone: 2     # Make sure we ran 2 tests\n</code></pre> <p>We can run this test file with the common <code>prove</code> command:</p> <pre><code>$ prove -v test-1.t\ntest-1.t ..\nok 1 - Test merge\nok 2 - Count keys\n1..2\nok\nAll tests successful.\nFiles=1, Tests=2,  0 wallclock secs ( 0.01 usr  0.00 sys +  0.01 cusr  0.00 csys =  0.02 CPU)\nResult: PASS\n</code></pre> <p>Tests are defined as a simple YAML sequence of mappings, one for each test. The <code>test</code> functions takes this sequence and runs each test in order.</p> <p>TAP needs to know that all the tests you intended to run were run. You can do this by calling the <code>plan</code> function beforehand with the number of tests you intend to run, or by calling the <code>done</code> afterwards with the number of tests you intended to run. You can also call <code>done</code> with no arguments (<code>done:</code>) to indicate that all tests were run.</p>"},{"location":"doc/ys-taptest/#test-mappings","title":"Test Mappings","text":"<p>Each test mapping has certain keys that determine how the test is run.</p> <p>You must specify <code>code</code> or <code>cmnd</code> for each test. This indicates either the YS code to run or the CLI command to run.</p> <p>You must specify one of <code>want</code>, <code>like</code> or <code>have</code> for each test. This indicates how the result should be tested.</p> <p>Here are the test mapping keys you can use in a test:</p> <ul> <li> <p><code>name</code> \u2014 The name/description of the test. This is optional.</p> </li> <li> <p><code>code</code> \u2014 The YS code to run for the test.</p> </li> <li> <p><code>cmnd</code> \u2014 The CLI command to run for the test.</p> </li> <li> <p><code>want</code> \u2014 The exact expected result of the test.</p> </li> <li> <p><code>like</code> \u2014 A regex pattern that the result should match.</p> </li> <li> <p><code>have</code> \u2014 A substring that the result should contain.</p> </li> <li> <p><code>what</code> \u2014 What part of the result to test.   Can be set to <code>value</code>, <code>error</code> or <code>out</code> for <code>code</code> tests and defaults to   <code>value</code>.   Can be set to <code>out</code>, <code>err</code>, <code>exit</code> or <code>all</code> for <code>cmnd</code> tests and defaults to   <code>out</code>.   See below for more information on these <code>what</code> values.</p> </li> <li> <p><code>form</code> \u2014 A function to format the result for testing.   The function will be called with the full result data and the current test   object.</p> </li> <li> <p><code>SKIP</code> \u2014 If set to <code>true</code>, this test will be skipped.   Can be used on multiple tests.</p> </li> <li> <p><code>ONLY</code> \u2014 If set to <code>true</code> only this test will be run.   Can be used on multiple tests.</p> </li> </ul>"},{"location":"doc/ys-taptest/#the-what-values","title":"The <code>what</code> Values","text":"<ul> <li> <p><code>value</code> \u2014 Test the return value of the code.   This is the default for <code>code</code> tests.</p> </li> <li> <p><code>error</code> \u2014 Test the error message of the code.   This expects the code to throw an error.</p> </li> <li> <p><code>out</code> \u2014 Test the stdout of the command.</p> </li> <li> <p><code>err</code> \u2014 Test the stderr of the command.</p> </li> <li> <p><code>exit</code> \u2014 Test the exit code of the command.</p> </li> <li> <p><code>all</code> \u2014 An object containing <code>out</code>, <code>err</code> and <code>exit</code> values.</p> </li> </ul>"},{"location":"doc/ys-taptest/#the-ystaptest-api-functions","title":"The ys::taptest API Functions","text":"<ul> <li> <p><code>done</code> \u2014 Indicate that a certain number of tests were run.   Run this after running all tests.</p> </li> <li> <p><code>plan</code> \u2014 Plan to run a certain number of tests.   Run this before running any tests.</p> </li> <li> <p><code>test</code> \u2014 Run a sequence of tests.</p> </li> </ul>"},{"location":"doc/ys-yaml/","title":"YAML Library","text":"<ul> <li><code>load(S)</code> \u2014 Load a YAML string to a native data structure.</li> <li><code>load-all(S)</code> \u2014 Load a YAML string into a list of document nodes.</li> <li><code>dump(X)</code> \u2014 Dump a native data structure to a YAML string.</li> <li><code>dump-all(V)</code> \u2014 Dump an array of native data structures to a multi-document YAML string.</li> </ul>"},{"location":"doc/ys-ys/","title":"YS Internals Library","text":"<p>This library serves 2 purposes. It provides functions for working with YS code from within a YS program/file.</p> <p>It also provides functions that are wrappers around common Clojure functions so that they can be used in places where functions are not allowed; like in dot chaining operations.</p> <p>You can use these functions with the <code>ys/</code> (or <code>ys::ys/</code>) prefix.</p>"},{"location":"doc/ys-ys/#ys-functions","title":"YS Functions","text":"<ul> <li> <p><code>compile</code> \u2014 Compile a YS string to a Clojure string</p> </li> <li> <p><code>eval</code> \u2014 Evaluate a YS string</p> </li> <li> <p><code>load-file</code> \u2014 Load a YS file path</p> </li> <li> <p><code>load-pod</code> \u2014 Load a Babashka Pod</p> </li> <li> <p><code>unload-pods</code> \u2014 Unload all loaded pods</p> </li> <li> <p><code>use</code> \u2014 Use a YS or Clojure library found in <code>YSPATH</code>.   Normally called as <code>use</code>, not <code>ys/use</code>.</p> </li> </ul>"},{"location":"doc/ys-ys/#macro-wrapper-functions","title":"Macro Wrapper Functions","text":"<ul> <li><code>for</code> \u2014 An eager version of Clojure's lazy <code>for</code> macro</li> <li><code>if</code> \u2014 Wrapper around the Clojure <code>if</code> special form</li> <li><code>when</code> \u2014 Wrapper around the Clojure <code>when</code> macro</li> </ul>"},{"location":"doc/ys/","title":"ys - The YS CLI Tool","text":"<p>The YS <code>ys</code> command line tool is the primary way to run, load and compile YS programs.</p> <p>Note</p> <p>Loading is essentially the same as running, but the result is output is printed as JSON.</p> <p>Here's the <code>ys --help</code> output:</p> <pre><code>$ ys --help\n\nys - The YS Command Line Tool - v0.1.95\n\nUsage: ys [&lt;option...&gt;] [&lt;file&gt;]\n\nOptions:\n\n  -e, --eval YSEXPR        Evaluate a YS expression\n                             multiple -e values are joined by newline\n  -l, --load               Output the (compact) JSON of YS evaluation\n  -f, --file FILE          Explicitly indicate input file\n\n  -c, --compile            Compile YS to Clojure\n  -b, --binary             Compile to a native binary executable\n\n  -p, --print              Print the final evaluation result value\n  -o, --output FILE        Output file for --load, --compile or --binary\n  -s, --stream             Output all results from a multi-document stream\n\n  -T, --to FORMAT          Output format for --load:\n                             json, yaml, csv, tsv, edn\n  -J, --json               Output (pretty) JSON for --load\n  -Y, --yaml               Output YAML for --load\n  -U, --unordered          Mappings don't preserve key order (faster)\n\n  -m, --mode MODE          Add a mode tag: code, data, or bare (for -e)\n  -C, --clojure            Treat input as Clojure code\n\n  -d                       Debug all compilation stages\n  -D, --debug-stage STAGE  Debug a specific compilation stage:\n                             parse, compose, resolve, build,\n                             transform, construct, print\n                           can be used multiple times\n  -S, --stack-trace        Print full stack trace for errors\n  -x, --xtrace             Print each expression before evaluation\n\n      --install            Install the libyamlscript shared library\n      --upgrade            Upgrade both ys and libyamlscript\n\n      --version            Print version and exit\n  -h, --help               Print this help and exit\n</code></pre> <p>Let's start with a YAML file (<code>some.yaml</code>) that wants to use data from another YAML file and also do some simple calculations:</p> <pre><code>!YS-v0:\n\n::\n  name =: \"World\"\n  data =: load(\"data1.yaml\")\n  fruit =: data.food.fruit\n\nnum: 123\ngreet:: \"$(data.hello.rand-nth()), $name!\"\neat:: fruit.shuffle().first()\ndrink:: ([\"Bar\"] * 3).join(', ').str('!!!')\n</code></pre> <p>Here's the other YAML file (<code>data1.yaml</code>):</p> <pre><code>food:\n  fruit:\n  - apple\n  - banana\n  - cherry\n  - date\n\nhello:\n- Aloha\n- Bonjour\n- Ciao\n- Dzie\u0144 dobry\n</code></pre> <p>We can \"load\" the YAML/YS file with the <code>ys</code> command and it will print the result as JSON:</p> <pre><code>$ ys -l some.yaml \n{\"num\":123,\"greet\":\"Bonjour, World!\",\"eat\":\"apple\",\"drink\":\"Bar, Bar, Bar!!!\"}\n</code></pre> <p>We can also format the output as YAML:</p> <pre><code> ys -lY some.yaml \nnum: 123\ngreet: Ciao, World!\neat: cherry\ndrink: Bar, Bar, Bar!!!\n</code></pre> <p>Here's a tiny YS program called <code>program.ys</code>:</p> <pre><code>!YS-v0\n\ndefn main(name='world' n=3):\n  greet: name n\n\ndefn greet(name, times=1):\n  each [i (1 .. times)]:\n    say: \"$i) Hello, $name!\"\n</code></pre> <p>We can run this program with the <code>ys</code> command:</p> <pre><code>$ time ys program.ys\n1) Hello, world!\n2) Hello, world!\n3) Hello, world!\n\nreal    0m0.021s\nuser    0m0.014s\nsys 0m0.007s\n</code></pre> <p>Pretty fast, right?</p> <p>We can pass in arguments:</p> <pre><code>$ ys program.ys Bob 2\n ys program.ys Bob 2\n1) Hello, Bob!\n2) Hello, Bob!\n</code></pre> <p>To see what Clojure code is being generated under the hood:</p> <pre><code>$ ys -c program.ys\n(declare greet)\n(defn main\n  ([name n] (greet name n))\n  ([name] (main name 3))\n  ([] (main \"world\" 3)))\n(defn greet\n  ([name times] (each [i (rng 1 times)] (say (str i \") Hello, \" name \"!\"))))\n  ([name] (greet name 1)))\n(apply main ARGS)\n</code></pre> <p>You can compile the program to a native binary executable:</p> <pre><code>$ time ys -b program.ys \n* Compiling YS 'program.ys' to 'program' executable\n* Setting up build env in '/tmp/tmp.xU8K3OPymt'\n* This may take a few minutes...\n[1/8] Initializing      (2.8s @ 0.14GB)\n[2/8] Performing analysis       (9.1s @ 0.33GB)\n[3/8] Building universe     (1.2s @ 0.39GB)\n[4/8] Parsing methods       (1.4s @ 0.41GB)\n[5/8] Inlining methods      (0.9s @ 0.49GB)\n[6/8] Compiling methods     (10.6s @ 0.50GB)\n[7/8] Layouting methods     (1.0s @ 0.50GB)\n[8/8] Creating image        (1.5s @ 0.44GB)\n* Compiled YS 'program.ys' to 'program' executable\n\nreal    0m36.340s\nuser    4m34.165s\nsys 0m3.915s\n\n$ time ./program Bob 2\n1) Hello, Bob!\n2) Hello, Bob!\n\nreal    0m0.007s\nuser    0m0.003s\nsys 0m0.004s\n</code></pre> <p>As you can see, the native binary is faster than the interpreted version, but the compilation takes quite a long time.</p> <p>When debugging, you can see the output of each compilation stage by adding the <code>-d</code> option:</p> <pre><code>$ ys -cd program.ys\n*** parse output ***\n({:+ \"+MAP\", :! \"YS-v0\"}\n {:+ \"=VAL\", := \"defn main(name='world' n=3)\"}\n {:+ \"+MAP\"}\n {:+ \"=VAL\", := \"greet\"}\n {:+ \"=VAL\", := \"name n\"}\n {:+ \"-MAP\"}\n {:+ \"=VAL\", := \"defn greet(name, times=1)\"}\n {:+ \"+MAP\"}\n {:+ \"=VAL\", := \"each [i (1 .. times)]\"}\n {:+ \"+MAP\"}\n {:+ \"=VAL\", := \"say\"}\n {:+ \"=VAL\", :$ \"$i) Hello, $name!\"}\n {:+ \"-MAP\"}\n {:+ \"-MAP\"}\n {:+ \"-MAP\"}\n {:+ \"-DOC\"})\n\n*** compose output ***\n{:! \"YS-v0\",\n :%\n [{:= \"defn main(name='world' n=3)\"}\n  {:% [{:= \"greet\"} {:= \"name n\"}]}\n  {:= \"defn greet(name, times=1)\"}\n  {:%\n   [{:= \"each [i (1 .. times)]\"}\n    {:% [{:= \"say\"} {:$ \"$i) Hello, $name!\"}]}]}]}\n\n*** resolve output ***\n{:xmap\n [{:defn \"defn main(name='world' n=3)\"}\n  {:xmap [{:expr \"greet\"} {:expr \"name n\"}]}\n  {:defn \"defn greet(name, times=1)\"}\n  {:xmap\n   [{:expr \"each [i (1 .. times)]\"}\n    {:xmap [{:expr \"say\"} {:xstr \"$i) Hello, $name!\"}]}]}]}\n\n*** build output ***\n{:xmap\n [[{:Sym defn} {:Sym main} nil]\n  [{:Lst\n    [{:Vec [{:Sym name} {:Sym n}]}\n     {:xmap [{:Sym greet} [{:Sym name} {:Sym n}]]}]}\n   {:Lst\n    [{:Vec [{:Sym name}]} {:Lst [{:Sym main} {:Sym name} {:Int 3}]}]}\n   {:Lst [{:Vec []} {:Lst [{:Sym main} {:Str \"world\"} {:Int 3}]}]}]\n  [{:Sym defn} {:Sym greet} nil]\n  [{:Lst\n    [{:Vec [{:Sym name} {:Sym times}]}\n     {:xmap\n      [[{:Sym each}\n        {:Vec [{:Sym i} {:Lst [{:Sym rng} {:Int 1} {:Sym times}]}]}]\n       {:xmap\n        [{:Sym say}\n         {:Lst\n          [{:Sym str}\n           {:Sym i}\n           {:Str \") Hello, \"}\n           {:Sym name}\n           {:Str \"!\"}]}]}]}]}\n   {:Lst\n    [{:Vec [{:Sym name}]}\n     {:Lst [{:Sym greet} {:Sym name} {:Int 1}]}]}]]}\n\n*** transform output ***\n{:xmap\n [[{:Sym defn} {:Sym main} nil]\n  [{:Lst\n    [{:Vec [{:Sym name} {:Sym n}]}\n     {:xmap [{:Sym greet} [{:Sym name} {:Sym n}]]}]}\n   {:Lst\n    [{:Vec [{:Sym name}]} {:Lst [{:Sym main} {:Sym name} {:Int 3}]}]}\n   {:Lst [{:Vec []} {:Lst [{:Sym main} {:Str \"world\"} {:Int 3}]}]}]\n  [{:Sym defn} {:Sym greet} nil]\n  [{:Lst\n    [{:Vec [{:Sym name} {:Sym times}]}\n     {:xmap\n      [[{:Sym each}\n        {:Vec [{:Sym i} {:Lst [{:Sym rng} {:Int 1} {:Sym times}]}]}]\n       {:xmap\n        [{:Sym say}\n         {:Lst\n          [{:Sym str}\n           {:Sym i}\n           {:Str \") Hello, \"}\n           {:Sym name}\n           {:Str \"!\"}]}]}]}]}\n   {:Lst\n    [{:Vec [{:Sym name}]}\n     {:Lst [{:Sym greet} {:Sym name} {:Int 1}]}]}]]}\n\n*** construct output ***\n{:Top\n [{:Lst [{:Sym declare} {:Sym greet}]}\n  {:Lst\n   [{:Sym defn}\n    {:Sym main}\n    nil\n    {:Lst\n     [{:Vec [{:Sym name} {:Sym n}]}\n      {:Lst [{:Sym greet} {:Sym name} {:Sym n}]}]}\n    {:Lst\n     [{:Vec [{:Sym name}]} {:Lst [{:Sym main} {:Sym name} {:Int 3}]}]}\n    {:Lst [{:Vec []} {:Lst [{:Sym main} {:Str \"world\"} {:Int 3}]}]}]}\n  {:Lst\n   [{:Sym defn}\n    {:Sym greet}\n    nil\n    {:Lst\n     [{:Vec [{:Sym name} {:Sym times}]}\n      {:Lst\n       [{:Sym each}\n        {:Vec [{:Sym i} {:Lst [{:Sym rng} {:Int 1} {:Sym times}]}]}\n        {:Lst\n         [{:Sym say}\n          {:Lst\n           [{:Sym str}\n            {:Sym i}\n            {:Str \") Hello, \"}\n            {:Sym name}\n            {:Str \"!\"}]}]}]}]}\n    {:Lst\n     [{:Vec [{:Sym name}]}\n      {:Lst [{:Sym greet} {:Sym name} {:Int 1}]}]}]}\n  {:Lst [{:Sym +++} {:Lst [{:Sym apply} {:Sym main} {:Sym ARGS}]}]}]}\n\n*** print output ***\n\"(declare greet)(defn main  ([name n] (greet name n)) ([name] (main name 3))...\n\n(declare greet)\n(defn main\n  ([name n] (greet name n))\n  ([name] (main name 3))\n  ([] (main \"world\" 3)))\n(defn greet\n  ([name times] (each [i (rng 1 times)] (say (str i \") Hello, \" name \"!\"))))\n  ([name] (greet name 1)))\n(+++ (apply main ARGS))\n</code></pre>"},{"location":"doc/ys4yaml/","title":"Extend Your YAML","text":"<p>If you want to use YS to get more out of your YAML files, this page is a good place to start.</p> <p>We'll cover the most common ways to use YS in YAML files without diving into all the YS details first.</p>"},{"location":"doc/ys4yaml/#turn-on-the-ys","title":"Turn On the YS!","text":"<p>It's an extremely good chance that your YAML files are already valid YAML.</p> <p>To find out, run a command like this:</p> <pre><code>$ ys -J your-file.yaml\n</code></pre> <p>If the output is your data converted to JSON, then you're good to go!</p> <p>To turn on YS functional capabilities, just add a <code>!YS-v0:</code> line to the top of your YAML file.</p> <p>Try running that command again. The output should be exactly the same as before.</p> <p>You've turned on YS but you haven't used it yet!</p>"},{"location":"doc/ys4yaml/#string-interpolation","title":"String Interpolation","text":"<p>YS supports the interpolation (expansion) of variables and expressions in double-quoted and literal YAML scalars (strings).</p> <p>First we need some variables to interpolate. We'll show how to define variables shortly, but for now we'll just use some of the global variables that are built into YS.</p> <p>The <code>ENV</code> variable is a great place to start, because it contains a map of your current environment variables. For instance you can access your <code>USER</code> variable with <code>ENV.USER</code>. Also let's use the <code>VERSION</code> variable, which contains the current YS version.</p> <p>Here's an example of string interpolation: <pre><code>!YS-v0:\nfoo: bar   # Normal YAML data\ngreeting: |\n  My name is $(ENV.USER).\n  I'm using YS $VERSION!\nbar: baz\n</code></pre></p> <p>Lets see load this file to YAML with the <code>ys</code> command: <pre><code>$ ys -Y file.yaml\nfoo: bar\ngreeting: |\n  My name is $(ENV.USER).\n  I'm using YS $VERSION!\nbar: baz\n</code></pre></p> <p>Well that's not what we expected. No interpolation happened!</p> <p>In order for the YS YAML loader to see a particular YAML node as YS code, we need to flip that node to code mode. YS makes this easy. Just change the <code>:</code> before that particuar node to <code>::</code>.</p> <pre><code>!YS-v0:\nfoo: bar   # Normal YAML data\ngreeting:: |\n  My name is $(ENV.USER).\n  I'm using YS $VERSION!\nbar: baz\n</code></pre> <p>And now we get the expected output: <pre><code>$ ys -Y file.yaml\nfoo: bar\ngreeting: |\n  My name is ingy.\n  I'm using YS 0.1.91!\nbar: baz\n</code></pre></p> <p>YS has 3 different ways to interpolate in strings:</p> <ul> <li>Expand variables: <code>\"I am $name.\"</code><ul> <li>Put a <code>$</code> in front of a variable name.</li> </ul> </li> <li>Expand expressions: <code>\"In reverse I'm $(name:reverse).\"</code><ul> <li>Put a <code>$()</code> around an expression.</li> </ul> </li> <li>Separate variable from text: <code>\"${name}ami!\"</code><ul> <li>Put a <code>${}</code> around a variable name when it is followed by alphanumeric   characters.</li> </ul> </li> </ul>"},{"location":"use/","title":"YS Use Cases","text":"<p>The primary goal of the YS project is to make YAML be able to do more.</p> <p>While the original goal of YAML was to be a human readable data serialization language, YAML has found its place in the world primarily as a software configuration language.</p> <p>YS has a strong focus on making YAML as good as possible for configuration. That said, YS is a complete, general purpose, functional programming language, that builds on top of the success of YAML, JSON, Clojure, Java and other technologies. It embeds perfectly into your YAML files, enabling almost any need you might have there, but it it also stands on its own in many other contexts.</p> <p>Check back here for more use cases as we add them.</p> <p>We hope you will find lots of excellent uses for YS. If you discover use cases that we haven't thought of, please let us know! We'll showcase them here.</p>"}]}